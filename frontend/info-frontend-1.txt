D:\...\frontend> ls


    Répertoire : D:\TOKY\PROJET\Recherche operationnel\demoucron\frontend


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----         6/23/2025   3:09 PM                node_modules
d-----         6/23/2025  11:45 AM                public
d-----         6/27/2025  10:45 AM                src
-a----         4/27/2025   5:10 PM            253 .gitignore
-a----         6/23/2025  12:55 PM            932 eslint.config.js
-a----         4/27/2025   6:03 PM            548 index.html
-a----         6/27/2025  10:37 AM         109591 info-frontend-1.txt
-a----         6/27/2025   9:49 AM         178143 package-lock.json
-a----         6/23/2025   3:09 PM           1249 package.json
-a----         4/27/2025   5:10 PM            856 README.md
-a----         6/23/2025   1:49 PM            193 vite.config.js


D:\...\frontend> tree /F .\src\
Structure du dossier pour le volume Stockage
Le numéro de série du volume est 0616-3CC8
D:\TOKY\PROJET\RECHERCHE OPERATIONNEL\DEMOUCRON\FRONTEND\SRC
│   App.jsx
│   index.jsx
│   styles.css
│
├───assets
│       react.svg
│
├───components
│       GraphEditor.jsx
│       GraphVisualizer.jsx
│       Header.jsx
│       MatrixInput.jsx
│       ResultsDisplay.jsx
│       WijGraph.jsx
│
└───lib
        logiqueMax.js
        logiqueMini.js
        type.js

D:\...\frontend> 

D:\...\frontend> cat .\src\App.jsx
"use client"

import { useState, useCallback, useEffect } from "react"
import { motion, AnimatePresence } from "framer-motion"
import Header from "./components/Header.jsx"
import GraphEditor from "./components/GraphEditor.jsx"
import MatrixInput from "./components/MatrixInput.jsx"
import GraphVisualizer from "./components/GraphVisualizer.jsx"
import ResultsDisplay from "./components/ResultsDisplay.jsx"
import { MinDemoucron } from "./lib/logiqueMini.js"
import { MaxDemoucron } from "./lib/logiqueMax.js"
import "./styles.css"

function App() {
  const [mode, setMode] = useState("matrix")
  const [theme, setTheme] = useState("light")
  const [visualizationData, setVisualizationData] = useState({
    nodes: [],
    edges: [],
    node_names: [],
    initial_matrix: [],
  })
  const [calculationData, setCalculationData] = useState(null)
  const [results, setResults] = useState(null)
  const [method, setMethod] = useState("min")
  const [isCalculating, setIsCalculating] = useState(false)

  useEffect(() => {
    if (theme === "dark") {
      document.documentElement.classList.add("dark")
    } else {
      document.documentElement.classList.remove("dark")
    }
  }, [theme])

  useEffect(() => {
    setVisualizationData({ nodes: [], edges: [], node_names: [], initial_matrix: [] })
    setCalculationData(null)
    setResults(null)
  }, [mode])

  const toggleTheme = useCallback(() => {
    setTheme(theme === "light" ? "dark" : "light")
  }, [theme])

  const handleGraphUpdate = useCallback((data) => {
    setVisualizationData({
      nodes: data.nodes || [],
      edges: data.edges || [],
      node_names: data.node_names || [],
      initial_matrix: data.initial_matrix || [],
    })
    setCalculationData({ type: "graph", data })
  }, [])

  const handleMatrixUpdate = useCallback((data) => {
    if (data) {
      const { matrix, node_names } = data
      const nodes = node_names.map((name, index) => ({ id: index, name, type: "normal" }))
      const edges = []
      for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[i].length; j++) {
          if (matrix[i][j] !== null && i !== j && matrix[i][j] !== Number.POSITIVE_INFINITY) {
            edges.push({ source: node_names[i], target: node_names[j], weight: matrix[i][j] })
          }
        }
      }
      setVisualizationData({ nodes, edges, node_names, initial_matrix: matrix })
      setCalculationData({ type: "matrix", matrix, node_names })
    } else {
      setVisualizationData({ nodes: [], edges: [], node_names: [], initial_matrix: [] })
      setCalculationData(null)
    }
  }, [])

  const handleCalculate = async () => {
    if (!calculationData) return
    setIsCalculating(true)
    try {
      let result
      let formData

      if (calculationData.type === "matrix" && calculationData.matrix) {
        formData = {
          methode: method,
          matrice: calculationData.matrix.map((row) =>
            row.map((cell) => (cell === null ? Number.POSITIVE_INFINITY : cell)),
          ),
          nbrMatrice: calculationData.node_names.length,
        }
      } else if (calculationData.type === "graph" && visualizationData.node_names.length > 0) {
        // Convertir les donnÃ©es du graphe en matrice
        const matrix = Array(visualizationData.node_names.length)
          .fill()
          .map(() => Array(visualizationData.node_names.length).fill(Number.POSITIVE_INFINITY))

        // Remplir la diagonale avec 0
        for (let i = 0; i < matrix.length; i++) {
          matrix[i][i] = 0
        }

        // Ajouter les arÃªtes
        visualizationData.edges.forEach((edge) => {
          const sourceIdx = visualizationData.node_names.indexOf(edge.source)
          const targetIdx = visualizationData.node_names.indexOf(edge.target)
          if (sourceIdx !== -1 && targetIdx !== -1) {
            matrix[sourceIdx][targetIdx] = edge.weight
          }
        })

        formData = {
          methode: method,
          matrice: matrix,
          nbrMatrice: visualizationData.node_names.length,
        }
      }

      if (formData) {
        result = method === "min" ? await MinDemoucron(formData) : await MaxDemoucron(formData)
        setResults(result)
      }
    } catch (error) {
      console.error("Calculation error:", error)
      setResults({ error: "Erreur lors du calcul: " + error.message })
    } finally {
      setIsCalculating(false)
    }
  }

  const canCalculate =
    calculationData &&
    ((calculationData.type === "matrix" && calculationData.matrix && calculationData.matrix.length > 0) ||
      (calculationData.type === "graph" && visualizationData.nodes.length > 0))

  return (
    <div className="app-container">
      <Header theme={theme} toggleTheme={toggleTheme} />

      <main className="main-content">
        <motion.div
          initial={{ opacity: 0, y: -30 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.8, ease: "easeOut" }}
          className="hero-section"
        >
          <div className="hero-background">
            <div className="hero-gradient"></div>
            <div className="hero-pattern"></div>
          </div>
          <div className="hero-content">
            <motion.h1
              className="hero-title"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.8, delay: 0.2 }}
            >
              Algorithme de Demoucron
            </motion.h1>
            <motion.p
              className="hero-description"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.8, delay: 0.4 }}
            >
              DÃ©couvrez les chemins optimaux avec une interface moderne et intuitive. CrÃ©ez votre graphe ou saisissez
              une matrice pour commencer l'analyse.
            </motion.p>
            <motion.div
              className="hero-stats"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.8, delay: 0.6 }}
            >
              <div className="stat-item">
                <div className="stat-number">âˆž</div>
                <div className="stat-label">PossibilitÃ©s</div>
              </div>
              <div className="stat-item">
                <div className="stat-number">O(nÂ³)</div>
                <div className="stat-label">ComplexitÃ©</div>
              </div>
              <div className="stat-item">
                <div className="stat-number">2</div>
                <div className="stat-label">Modes</div>
              </div>
            </motion.div>
          </div>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.6, delay: 0.3 }}
          className="mode-selector-container"
        >
          <div className="mode-selector">
            <motion.button
              onClick={() => setMode("graph")}
              className={`mode-btn ${mode === "graph" ? "active" : ""}`}
              whileHover={{ scale: 1.02 }}
              whileTap={{ scale: 0.98 }}
            >
              <svg className="mode-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M11 4a2 2 0 114 0v4a1 1 0 001 1h3a1 1 0 011 1v3a1 1 0 01-1 1h-1a2 2 0 100 4h1a1 1 0 011 1v3a1 1 0 01-1 1h-3a1 1 0 01-1-1v-1a2 2 0 10-4 0v1a1 1 0 01-1 1H7a1 1 0 01-1-1v-3a1 1 0 00-1-1H4a1 1 0 01-1-1V9a1 1 0 011-1h1a2 2 0 100-4H4a1 1 0 01-1-1V4a1 1 0 011-1h3a1 1 0 001-1v-1a2 2 0 114 0z"
                />
              </svg>
              <span>Ã‰diteur de Graphe</span>
              <div className="mode-badge">Interactif</div>
            </motion.button>
            <motion.button
              onClick={() => setMode("matrix")}
              className={`mode-btn ${mode === "matrix" ? "active" : ""}`}
              whileHover={{ scale: 1.02 }}
              whileTap={{ scale: 0.98 }}
            >
              <svg className="mode-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"
                />
              </svg>
              <span>EntrÃ©e Matricielle</span>
              <div className="mode-badge">PrÃ©cis</div>
            </motion.button>
          </div>
        </motion.div>

        <div className="workspace-grid">
          <AnimatePresence mode="wait">
            {mode === "graph" && (
              <motion.div
                key="graph-editor"
                initial={{ opacity: 0, x: -50 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: -50 }}
                transition={{ duration: 0.5 }}
                className="workspace-panel"
              >
                <GraphEditor onUpdate={handleGraphUpdate} theme={theme} />
              </motion.div>
            )}
            {mode === "matrix" && (
              <motion.div
                key="matrix-input"
                initial={{ opacity: 0, x: -50 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: -50 }}
                transition={{ duration: 0.5 }}
                className="workspace-panel"
              >
                <MatrixInput onMatrixUpdate={handleMatrixUpdate} theme={theme} />
              </motion.div>
            )}
          </AnimatePresence>

          <motion.div
            initial={{ opacity: 0, x: 50 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ duration: 0.5, delay: 0.2 }}
            className="workspace-panel"
          >
            <GraphVisualizer
              nodes={visualizationData.nodes}
              edges={visualizationData.edges}
              theme={theme}
              nodeNames={visualizationData.node_names}
              initialMatrix={visualizationData.initial_matrix}
            />
          </motion.div>
        </div>

        <motion.div
          initial={{ opacity: 0, y: 30 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.6, delay: 0.4 }}
          className="calculation-panel"
        >
          <div className="calculation-header">
            <div className="calculation-title">
              <svg className="calculation-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
              </svg>
              <div>
                <h3>Configuration du Calcul</h3>
                <p>Choisissez votre mÃ©thode d'optimisation</p>
              </div>
            </div>
          </div>

          <div className="method-selection">
            <div className="method-options">
              <motion.label
                className={`method-option ${method === "min" ? "selected" : ""}`}
                whileHover={{ scale: 1.02 }}
                whileTap={{ scale: 0.98 }}
              >
                <input
                  type="radio"
                  value="min"
                  checked={method === "min"}
                  onChange={() => setMethod("min")}
                  className="method-radio"
                />
                <div className="method-content">
                  <div className="method-icon min">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M19 14l-7 7m0 0l-7-7m7 7V3"
                      />
                    </svg>
                  </div>
                  <div className="method-info">
                    <span className="method-name">Minimisation</span>
                    <span className="method-desc">Trouve le chemin le plus court</span>
                  </div>
                </div>
                <div className="method-indicator"></div>
              </motion.label>

              <motion.label
                className={`method-option ${method === "max" ? "selected" : ""}`}
                whileHover={{ scale: 1.02 }}
                whileTap={{ scale: 0.98 }}
              >
                <input
                  type="radio"
                  value="max"
                  checked={method === "max"}
                  onChange={() => setMethod("max")}
                  className="method-radio"
                />
                <div className="method-content">
                  <div className="method-icon max">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M5 10l7-7m0 0l7 7m-7-7v18"
                      />
                    </svg>
                  </div>
                  <div className="method-info">
                    <span className="method-name">Maximisation</span>
                    <span className="method-desc">Trouve le chemin le plus long</span>
                  </div>
                </div>
                <div className="method-indicator"></div>
              </motion.label>
            </div>

            <motion.button
              onClick={handleCalculate}
              disabled={!canCalculate || isCalculating}
              whileHover={{ scale: canCalculate && !isCalculating ? 1.02 : 1 }}
              whileTap={{ scale: canCalculate && !isCalculating ? 0.98 : 1 }}
              className="calculate-btn"
            >
              <AnimatePresence mode="wait">
                {isCalculating ? (
                  <motion.div
                    key="loading"
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                    className="btn-content"
                  >
                    <div className="loading-spinner"></div>
                    <span>Calcul en cours...</span>
                  </motion.div>
                ) : (
                  <motion.div
                    key="calculate"
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                    className="btn-content"
                  >
                    <svg className="btn-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M13 10V3L4 14h7v7l9-11h-7z"
                      />
                    </svg>
                    <span>Calculer les Chemins Optimaux</span>
                  </motion.div>
                )}
              </AnimatePresence>
            </motion.button>
          </div>
        </motion.div>

        <AnimatePresence>
          {results && (
            <motion.div
              initial={{ opacity: 0, y: 50 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 50 }}
              transition={{ duration: 0.6 }}
              className="results-container"
            >
              <ResultsDisplay
                results={results}
                theme={theme}
                nodes={visualizationData.nodes}
                nodeNames={visualizationData.node_names}
              />
            </motion.div>
          )}
        </AnimatePresence>
      </main>
    </div>
  )
}

export default App
D:\...\frontend> cat .\src\index.jsx
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.jsx";
import "./styles.css";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
D:\...\frontend>

D:\...\frontend> cat .\src\styles.css
D:\...\frontend> cat .\src\lib\*
// src/lib/logiqueMax.js

export async function MaxDemoucron(formData) {
  const { methode, matrice, nbrMatrice } = formData

  if (!methode) {
    return { 
      steps: [], 
      finalMatrix: [], 
      predecessors: [], 
      optimalPaths: {}, 
      error: "Veuillez sÃ©lectionner une mÃ©thode (min ou max)." 
    }
  }

  if (nbrMatrice <= 0 || !matrice || matrice.length !== nbrMatrice || matrice[0].length !== nbrMatrice) {
    return {
      steps: [],
      finalMatrix: [],
      predecessors: [],
      optimalPaths: {},
      error: "Matrice invalide ou nombre de matrices incorrect."
    }
  }

  const currentMatrix = matrice.map(row => [...row])
  const steps = []
  const predecessors = Array.from({ length: nbrMatrice }, (_, i) =>
    Array.from({ length: nbrMatrice }, (_, j) => (currentMatrix[i][j] !== Infinity && i !== j ? i : -1))
  )

  for (let k = 2; k <= nbrMatrice - 1; k++) {
    const W = []
    const V = []
    const kIdx = k - 1

    const verticesToK = []
    for (let i = 1; i <= nbrMatrice; i++) {
      const iIdx = i - 1
      if (i !== k && currentMatrix[iIdx][kIdx] !== Infinity) {
        verticesToK.push(i)
      }
    }

    const verticesFromK = []
    for (let j = 1; j <= nbrMatrice; j++) {
      const jIdx = j - 1
      if (j !== k && currentMatrix[kIdx][jIdx] !== Infinity) {
        verticesFromK.push(j)
      }
    }

    for (const i of verticesToK) {
      for (const j of verticesFromK) {
        const iIdx = i - 1
        const jIdx = j - 1

        const V_ik = currentMatrix[iIdx][kIdx]
        const V_kj = currentMatrix[kIdx][jIdx]
        let W_value

        if (V_ik === Infinity || V_kj === Infinity) {
          W_value = Infinity
        } else {
          W_value = V_ik + V_kj
        }

        W.push({
          i,
          j,
          value: W_value,
          formula: `W_${i}${j}^(${k-1}) = V_${i}${k}^(${k-1}) + V_${k}${j}^(${k-1}) = ${V_ik === Infinity ? "+âˆž" : V_ik} + ${V_kj === Infinity ? "+âˆž" : V_kj} = ${W_value === Infinity ? "+âˆž" : W_value}`
        })

        const V_ij = currentMatrix[iIdx][jIdx]
        const new_V_value = methode === "max" ? Math.max(W_value, V_ij) : Math.min(W_value, V_ij)

        V.push({
          i,
          j,
          value: new_V_value,
          formula: `V_${i}${j}^(${k}) = ${methode === "max" ? "MAX" : "MIN"}(W_${i}${j}^(${k-1}), V_${i}${j}^(${k-1})) = ${methode === "max" ? "MAX" : "MIN"}(${W_value === Infinity ? "+âˆž" : W_value}, ${V_ij === Infinity ? "+âˆž" : V_ij}) = ${new_V_value === Infinity ? "+âˆž" : new_V_value}`
        })

        if ((methode === "max" && new_V_value > currentMatrix[iIdx][jIdx]) ||
            (methode === "min" && new_V_value < currentMatrix[iIdx][jIdx])) {
          currentMatrix[iIdx][jIdx] = new_V_value
          predecessors[iIdx][jIdx] = predecessors[kIdx][jIdx]
        }
      }
    }

    const matrixCopy = currentMatrix.map(row => [...row])
    steps.push({ k, W, V, matrix: matrixCopy })
  }

  // Construire les chemins optimaux en partant de la derniÃ¨re colonne
  const optimalPaths = {}

  const findOptimalPathFromLastColumn = () => {
    const path = []
    let currentCol = nbrMatrice - 1 // DerniÃ¨re colonne

    while (currentCol >= 0) {
      let optimalValue = methode === "max" ? -Infinity : Infinity
      let optimalRow = -1

      // Chercher la valeur optimale dans la colonne actuelle
      for (let i = 0; i < nbrMatrice; i++) {
        if (i !== currentCol) {
          const value = currentMatrix[i][currentCol]
          if (methode === "max" && value > optimalValue && value !== Infinity) {
            optimalValue = value
            optimalRow = i
          } else if (methode === "min" && value < optimalValue) {
            optimalValue = value
            optimalRow = i
          }
        }
      }

      if (optimalRow === -1 || optimalValue === Infinity) break
      if (path.includes(optimalRow + 1)) break // Ã‰viter les boucles

      path.unshift(optimalRow + 1) // Ajouter le sommet au dÃ©but du chemin
      currentCol = optimalRow // Passer Ã  la colonne correspondant Ã  la ligne optimale
    }

    // Ajouter la derniÃ¨re colonne au chemin
    path.push(nbrMatrice)
    return path
  }

  // Calculer le chemin optimal unique Ã  partir de la derniÃ¨re colonne
  const optimalPath = findOptimalPathFromLastColumn()
  if (optimalPath.length > 1) {
    // Stocker le chemin dans optimalPaths avec la clÃ© "1-n" (du premier au dernier sommet)
    optimalPaths[`1-${nbrMatrice}`] = optimalPath
  }

  return {
    steps,
    finalMatrix: currentMatrix,
    predecessors,
    optimalPaths
  }
}
// src/lib/logiqueMini.js
export async function MinDemoucron(formData) {
  const { methode, matrice, nbrMatrice } = formData

  if (!methode) {
    return {
      steps: [],
      finalMatrix: [],
      predecessors: [],
      optimalPaths: {},
      error: "Veuillez sÃ©lectionner une mÃ©thode (min ou max)."
    }
  }

  if (nbrMatrice <= 0 || !matrice || matrice.length !== nbrMatrice || matrice[0].length !== nbrMatrice) {
    return {
      steps: [],
      finalMatrix: [],
      predecessors: [],
      optimalPaths: {},
      error: "Matrice invalide ou nombre de matrices incorrect."
    }
  }

  const currentMatrix = matrice.map(row => [...row])
  const steps = []
  const predecessors = Array.from({ length: nbrMatrice }, (_, i) =>
    Array.from({ length: nbrMatrice }, (_, j) => (currentMatrix[i][j] !== Infinity && i !== j ? i : -1))
  )

  for (let k = 2; k <= nbrMatrice - 1; k++) {
    const W = []
    const V = []
    const kIdx = k - 1

    const verticesToK = []
    for (let i = 1; i <= nbrMatrice; i++) {
      const iIdx = i - 1
      if (i !== k && currentMatrix[iIdx][kIdx] !== Infinity) {
        verticesToK.push(i)
      }
    }

    const verticesFromK = []
    for (let j = 1; j <= nbrMatrice; j++) {
      const jIdx = j - 1
      if (j !== k && currentMatrix[kIdx][jIdx] !== Infinity) {
        verticesFromK.push(j)
      }
    }

    for (const i of verticesToK) {
      for (const j of verticesFromK) {
        const iIdx = i - 1
        const jIdx = j - 1

        const V_ik = currentMatrix[iIdx][kIdx]
        const V_kj = currentMatrix[kIdx][jIdx]
        let W_value

        if (V_ik === Infinity || V_kj === Infinity) {
          W_value = Infinity
        } else {
          W_value = V_ik + V_kj
        }

        W.push({
          i,
          j,
          value: W_value,
          formula: `W_${i}${j}^(${k-1}) = V_${i}${k}^(${k-1}) + V_${k}${j}^(${k-1}) = ${V_ik === Infinity ? "+âˆž" : V_ik} + ${V_kj === Infinity ? "+âˆž" : V_kj} = ${W_value === Infinity ? "+âˆž" : W_value}`
        })

        const V_ij = currentMatrix[iIdx][jIdx]
        const new_V_value = methode === "min" ? Math.min(W_value, V_ij) : Math.max(W_value, V_ij)

        V.push({
          i,
          j,
          value: new_V_value,
          formula: `V_${i}${j}^(${k}) = ${methode === "min" ? "MIN" : "MAX"}(W_${i}${j}^(${k-1}}, V_${i}${j}^(${k-1})) = ${methode === "min" ? "MIN" : "MAX"}(${W_value === Infinity ? "+âˆž" : W_value}, ${V_ij === Infinity ? "+âˆž" : V_ij}) = ${new_V_value === Infinity ? "+âˆž" : new_V_value}`
        })

        if ((methode === "min" && new_V_value < currentMatrix[iIdx][jIdx]) ||
            (methode === "max" && new_V_value > currentMatrix[iIdx][jIdx])) {
          currentMatrix[iIdx][jIdx] = new_V_value
          predecessors[iIdx][jIdx] = predecessors[kIdx][jIdx]
        }
      }
    }

    const matrixCopy = currentMatrix.map(row => [...row])
    steps.push({ k, W, V, matrix: matrixCopy })
  }

  // Construire les chemins optimaux en partant de la derniÃ¨re colonne
  const optimalPaths = {}

  const findOptimalPathFromEnd = (end, start) => {
    const path = [end + 1]
    let currentCol = end

    while (currentCol >= 0) {
      let optimalValue = methode === "min" ? Infinity : -Infinity
      let optimalRow = -1

      for (let i = 0; i < nbrMatrice; i++) {
        if (i !== currentCol) {
          const value = currentMatrix[i][currentCol]
          if (methode === "min" && value < optimalValue) {
            optimalValue = value
            optimalRow = i
          } else if (methode === "max" && value > optimalValue && value !== Infinity) {
            optimalValue = value
            optimalRow = i
          }
        }
      }

      if (optimalRow === -1 || optimalValue === Infinity) break
      if (path.includes(optimalRow + 1)) break

      path.unshift(optimalRow + 1)
      if (start !== undefined && optimalRow === start) break
      currentCol = optimalRow
    }

    return path
  }

  const lastColumn = nbrMatrice - 1
  for (let i = 0; i < nbrMatrice; i++) {
    if (i !== lastColumn && currentMatrix[i][lastColumn] !== Infinity) {
      const path = findOptimalPathFromEnd(lastColumn, i)
      if (path.length > 1 && path[0] === i + 1) {
        optimalPaths[`${i + 1}-${lastColumn + 1}`] = path
      }
    }
  }

  return {
    steps,
    finalMatrix: currentMatrix,
    predecessors,
    optimalPaths
  }
}
// Types pour les donnÃ©es du formulaire
export const createFormData = (methode = "", matrice = [], nbrMatrice = 0) => ({
  methode,
  matrice,
  nbrMatrice
})

// Types pour les dÃ©tails des Ã©tapes
export const createStepDetail = (i, j, value, formula) => ({
  i,
  j,
  value,
  formula
})

// Types pour les Ã©tapes
export const createStep = (k, W = [], V = [], matrix = []) => ({
  k,
  W,
  V,
  matrix
})

// Types pour les positions des nÅ“uds
export const createNodePosition = (x, y) => ({
  x,
  y
})
D:\...\frontend> 
D:\...\frontend> cat .\src\components\GraphEditor.jsx
import { useState, useEffect, useCallback } from "react";
import { motion, AnimatePresence } from "framer-motion";
import axios from "axios";

function GraphEditor({ onUpdate, theme }) {
  const [graphId, setGraphId] = useState(null);
  const [graphName, setGraphName] = useState("");
  const [graphs, setGraphs] = useState([]);
  const [selectedGraph, setSelectedGraph] = useState("");
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);
  const [nodeName, setNodeName] = useState("");
  const [nodeType, setNodeType] = useState("normal");
  const [source, setSource] = useState("");
  const [target, setTarget] = useState("");
  const [weight, setWeight] = useState("");
  const [loading, setLoading] = useState(false);
  const [notification, setNotification] = useState({ show: false, message: "", type: "success" });

  const loadGraphs = useCallback(async () => {
    setLoading(true);
    try {
      const response = await axios.get("http://localhost:8000/api/graphs/");
      setGraphs(response.data);
    } catch (error) {
      setNotification({ show: true, message: `Erreur de connexion: ${error.message}`, type: "error" });
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    loadGraphs();
  }, [loadGraphs]);

  const loadGraphDetails = useCallback(async (graphId) => {
    if (!graphId) {
      setGraphId(null);
      setNodes([]);
      setEdges([]);
      onUpdate({ nodes: [], edges: [], node_names: [], initial_matrix: [], graphId: null });
      return;
    }
    setLoading(true);
    try {
      const response = await axios.get(`http://localhost:8000/api/graphs/${graphId}/`);
      const data = response.data;
      setGraphId(data.id);
      setNodes(data.sommets || []);
      setEdges(data.arcs || []);
      setNotification({ show: true, message: `Graphe '${data.name}' chargÃ© avec succÃ¨s`, type: "success" });
      onUpdate({
        nodes: data.sommets || [],
        edges: data.arcs || [],
        node_names: data.node_names || [],
        initial_matrix: data.initial_matrix || [],
        graphId: data.id
      });
    } catch (error) {
      setNotification({ show: true, message: `Erreur de connexion: ${error.message}`, type: "error" });
      onUpdate({ error: "Erreur lors du chargement du graphe" });
    } finally {
      setLoading(false);
    }
  }, [onUpdate]);

  useEffect(() => {
    loadGraphDetails(selectedGraph);
  }, [selectedGraph, loadGraphDetails]);

  const createGraph = async () => {
    if (!graphName) {
      setNotification({ show: true, message: "Veuillez entrer un nom pour le graphe", type: "error" });
      return;
    }
    setLoading(true);
    try {
      const response = await axios.post("http://localhost:8000/api/graphs/create/", { name: graphName });
      const newGraph = response.data;
      setGraphs((prevGraphs) => [...prevGraphs, newGraph]);
      setSelectedGraph(String(newGraph.id));
      setGraphName("");
      setNotification({ show: true, message: `Graphe '${newGraph.name}' crÃ©Ã© avec succÃ¨s`, type: "success" });
    } catch (error) {
      setNotification({ show: true, message: `Erreur de connexion: ${error.message}`, type: "error" });
    } finally {
      setLoading(false);
    }
  };

  const addNode = async () => {
    if (!nodeName) {
      setNotification({ show: true, message: "Veuillez entrer un nom pour le sommet", type: "error" });
      return;
    }
    if (!graphId) {
      setNotification({ show: true, message: "Veuillez crÃ©er ou sÃ©lectionner un graphe d'abord", type: "error" });
      return;
    }
    if (nodes.some((n) => n.name === nodeName)) {
      setNotification({ show: true, message: `Le sommet '${nodeName}' existe dÃ©jÃ `, type: "error" });
      return;
    }
    setLoading(true);
    try {
      await axios.post(`http://localhost:8000/api/graphs/${graphId}/add_sommet/`, { name: nodeName, type: nodeType });
      await loadGraphDetails(graphId);
      setNodeName("");
      setNodeType("normal");
      setNotification({ show: true, message: `Sommet '${nodeName}' ajoutÃ© avec succÃ¨s`, type: "success" });
    } catch (error) {
      setNotification({ show: true, message: `Erreur de connexion: ${error.message}`, type: "error" });
    } finally {
      setLoading(false);
    }
  };

  const addEdge = async () => {
    if (!source || !target || !weight) {
      setNotification({ show: true, message: "Veuillez remplir tous les champs pour l'arc", type: "error" });
      return;
    }
    if (!graphId) {
      setNotification({ show: true, message: "Veuillez crÃ©er ou sÃ©lectionner un graphe d'abord", type: "error" });
      return;
    }
    if (source === target) {
      setNotification({ show: true, message: "La source et la cible ne peuvent pas Ãªtre identiques", type: "error" });
      return;
    }
    setLoading(true);
    try {
      await axios.post(`http://localhost:8000/api/graphs/${graphId}/add_arc/`, {
        source,
        target,
        weight: Number.parseFloat(weight)
      });
      await loadGraphDetails(graphId);
      setSource("");
      setTarget("");
      setWeight("");
      setNotification({ show: true, message: `Arc de '${source}' Ã  '${target}' ajoutÃ© avec succÃ¨s`, type: "success" });
    } catch (error) {
      setNotification({ show: true, message: `Erreur de connexion: ${error.message}`, type: "error" });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (notification.show) {
      const timer = setTimeout(() => setNotification({ show: false, message: "", type: "success" }), 4000);
      return () => clearTimeout(timer);
    }
  }, [notification]);

  const getNodeTypeIcon = (type) => {
    switch (type) {
      case "initial":
        return <svg className="node-type-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 3h14a2 2 0 012 2v14a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2m4 7h6" /></svg>;
      case "final":
        return <svg className="node-type-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>;
      default:
        return <svg className="node-type-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" /></svg>;
    }
  };

  return (
    <div className="graph-editor">
      <div className="panel-header">
        <div className="panel-icon">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 4a2 2 0 114 0v4a1 1 0 001 1h3a1 1 0 011 1v3a1 1 0 01-1 1h-1a2 2 0 100 4h1a1 1 0 011 1v3a1 1 0 01-1 1h-3a1 1 0 01-1-1v-1a2 2 0 10-4 0v1a1 1 0 01-1 1H7a1 1 0 01-1-1v-3a1 1 0 00-1-1H4a1 1 0 01-1-1V9a1 1 0 011-1h1a2 2 0 100-4H4a1 1 0 01-1-1V4a1 1 0 011-1h3a1 1 0 001-1v-1a2 2 0 114 0z" />
          </svg>
        </div>
        <div className="panel-title">
          <h2>Ã‰diteur de Graphe</h2>
          <p>CrÃ©ez et modifiez votre graphe interactivement</p>
        </div>
      </div>

      <AnimatePresence>
        {notification.show && (
          <motion.div
            initial={{ opacity: 0, y: -20, scale: 0.95 }}
            animate={{ opacity: 1, y: 0, scale: 1 }}
            exit={{ opacity: 0, y: -20, scale: 0.95 }}
            transition={{ duration: 0.3 }}
            className={`notification ${notification.type}`}
          >
            <div className="notification-icon">
              {notification.type === "error" ? (
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
              ) : (
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /> 
                </svg>
              )}
            </div>
            <span>{notification.message}</span>
          </motion.div>
        )}
      </AnimatePresence>

      <div className="editor-sections">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5, delay: 0.1 }}
          className="editor-section"
        >
          <div className="section-header">
            <h3>Gestion du Graphe</h3>
            <button onClick={loadGraphs} disabled={loading} className="refresh-btn">
              <svg className={loading ? "spinning" : ""} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m0 0a8.001 8.001 0 0115.356 2m-15.356-2H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
              </svg>
            </button>
          </div>
          <div className="form-grid">
            <div className="form-group">
              <label>SÃ©lectionner un graphe</label>
              <select value={selectedGraph} onChange={(e) => setSelectedGraph(e.target.value)} className="form-select">
                <option value="">Choisir un graphe existant</option>
                {graphs.map((g) => <option key={g.id} value={g.id}>{g.name}</option>)}
              </select>
            </div>
            <div className="form-group">
              <label>Nouveau graphe</label>
              <div className="input-group">
                <input
                  type="text"
                  value={graphName}
                  onChange={(e) => setGraphName(e.target.value)}
                  placeholder="Nom du graphe"
                  className="form-input"
                />
                <button onClick={createGraph} disabled={loading} className="btn btn-primary">
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                  </svg>
                </button>
              </div>
            </div>
          </div>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5, delay: 0.2 }}
          className="editor-section"
        >
          <div className="section-header">
            <h3>Ajouter un Sommet</h3>
          </div>
          <div className="form-grid">
            <div className="form-group">
              <label>Nom du sommet</label>
              <input
                type="text"
                value={nodeName}
                onChange={(e) => setNodeName(e.target.value)}
                placeholder="Ex: A, B, C..."
                className="form-input"
              />
            </div>
            <div className="form-group">
              <label>Type de sommet</label>
              <select value={nodeType} onChange={(e) => setNodeType(e.target.value)} className="form-select">
                <option value="normal">Normal</option>
                <option value="initial">Initial</option>
                <option value="final">Final</option>
              </select>
            </div>
            <div className="form-group">
              <button onClick={addNode} disabled={loading} className="btn btn-success full-width">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                </svg>
                Ajouter Sommet
              </button>
            </div>
          </div>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5, delay: 0.3 }}
          className="editor-section"
        >
          <div className="section-header">
            <h3>Ajouter un Arc</h3>
          </div>
          <div className="form-grid">
            <div className="form-group">
              <label>Source</label>
              <select value={source} onChange={(e) => setSource(e.target.value)} className="form-select">
                <option value="">Choisir</option>
                {nodes.map((n) => <option key={n.id} value={n.name}>{n.name}</option>)}
              </select>
            </div>
            <div className="form-group">
              <label>Cible</label>
              <select value={target} onChange={(e) => setTarget(e.target.value)} className="form-select">
                <option value="">Choisir</option>
                {nodes.map((n) => <option key={n.id} value={n.name}>{n.name}</option>)}
              </select>
            </div>
            <div className="form-group">
              <label>Poids</label>
              <input
                type="number"
                value={weight}
                onChange={(e) => setWeight(e.target.value)}
                placeholder="0"
                className="form-input"
              />
            </div>
            <div className="form-group">
              <button onClick={addEdge} disabled={loading} className="btn btn-purple full-width">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.828 10.172a4 0 00-5.656 0l-4 4a4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 0 005.5 0l4-4a4 0 00-5.656-5.656l-1.1 1.1" />
                </svg>
                Ajouter Arc
              </button>
            </div>
          </div>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5, delay: 0.4 }}
          className="summary-section"
        >
          <div className="summary-grid">
            <div className="summary-card">
              <div className="summary-header">
                <h4>Sommets ({nodes.length})</h4>
              </div>
              <div className="summary-content">
                {nodes.length > 0 ? (
                  <div className="node-list">
                    {nodes.map((n) => (
                      <div key={n.id} className={`node-item ${n.type}`}>
                        {getNodeTypeIcon(n.type)}
                        <span className="node-name">{n.name}</span>
                        <span className="node-type">{n.type}</span>
                      </div>
                    ))}
                  </div>
                ) : (
                  <p className="empty-state">Aucun sommet ajoutÃ©</p>
                )}
              </div>
            </div>

            <div className="summary-card">
              <div className="summary-header">
                <h4>Arcs ({edges.length})</h4>
              </div>
              <div className="summary-content">
                {edges.length > 0 ? (
                  <div className="edge-list">
                    {edges.map((e, index) => (
                      <div key={index} className="edge-item">
                        <span className="edge-source">{e.source}</span>
                        <svg className="edge-arrow" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 8l4 4m0 0l-4 4m4-4H3" />
                        </svg>
                        <span className="edge-target">{e.target}</span>
                        <span className="edge-weight">({e.weight})</span>
                      </div>
                    ))}
                  </div>
                ) : (
                  <p className="empty-state">Aucun arc ajoutÃ©</p>
                )}
              </div>
            </div>
          </div>
        </motion.div>
      </div>
    </div>
  );
}

export default GraphEditor;
D:\...\frontend> 
D:\...\frontend> cat .\src\components\GraphVisualizer.jsx
import { useMemo } from "react";
import ReactFlow, { Background, Controls, MiniMap } from "reactflow";
import "reactflow/dist/style.css";
import { motion } from "framer-motion";

const nodeTypes = {
  custom: ({ data }) => (
    <motion.div
      initial={{ scale: 0 }}
      animate={{ scale: 1 }}
      whileHover={{ scale: 1.1 }}
      transition={{ type: "spring", stiffness: 400, damping: 10 }}
      className="custom-node"
      style={{
        background: data.gradient,
        boxShadow: data.shadow,
      }}
    >
      <span className="node-label">{data.label}</span>
      {data.type !== "normal" && (
        <div className="node-indicator">
          {data.type === "initial" ? "S" : "T"}
        </div>
      )}
    </motion.div>
  ),
};

function GraphVisualizer({ nodes, edges, theme, nodeNames, initialMatrix }) {
  const themeConfig = {
    light: {
      background: "linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%)",
      nodeInitial: "linear-gradient(135deg, #10b981, #059669)",
      nodeFinal: "linear-gradient(135deg, #ef4444, #dc2626)",
      nodeNormal: "linear-gradient(135deg, #3b82f6, #2563eb)",
      edgeColor: "#475569",
      shadowInitial: "0 8px 25px rgba(16, 185, 129, 0.3)",
      shadowFinal: "0 8px 25px rgba(239, 68, 68, 0.3)",
      shadowNormal: "0 8px 25px rgba(59, 130, 246, 0.3)",
    },
    dark: {
      background: "linear-gradient(135deg, #0f172a 0%, #1e293b 100%)",
      nodeInitial: "linear-gradient(135deg, #10b981, #059669)",
      nodeFinal: "linear-gradient(135deg, #ef4444, #dc2626)",
      nodeNormal: "linear-gradient(135deg, #3b82f6, #2563eb)",
      edgeColor: "#94a3b8",
      shadowInitial: "0 8px 25px rgba(16, 185, 129, 0.4)",
      shadowFinal: "0 8px 25px rgba(239, 68, 68, 0.4)",
      shadowNormal: "0 8px 25px rgba(59, 130, 246, 0.4)",
    },
  };

  const currentTheme = themeConfig[theme] || themeConfig.light;

  const normalizedNodes = useMemo(() => {
    if (!nodes || nodes.length === 0) return [];
    return nodes.map((n, index) => {
      const nodeType = n.type || "normal";
      return {
        id: `${n.id || index}`,
        type: "custom",
        data: {
          label: n.name,
          type: nodeType,
          gradient: nodeType === "initial" ? currentTheme.nodeInitial :
                   nodeType === "final" ? currentTheme.nodeFinal :
                   currentTheme.nodeNormal,
          shadow: nodeType === "initial" ? currentTheme.shadowInitial :
                  nodeType === "final" ? currentTheme.shadowFinal :
                  currentTheme.shadowNormal,
        },
        position: {
          x: 150 + (index % 4) * 200,
          y: 150 + Math.floor(index / 4) * 150
        },
        draggable: true,
      };
    });
  }, [nodes, currentTheme]);

  const reactFlowEdges = useMemo(() => {
    if (!edges || !nodes || edges.length === 0) return [];
    return edges
      .map((e, index) => {
        const sourceNode = nodes.find((n) => n.name.toLowerCase() === e.source.toLowerCase());
        const targetNode = nodes.find((n) => n.name.toLowerCase() === e.target.toLowerCase());
        if (!sourceNode || !targetNode) return null;
        if (!e.weight || isNaN(Number(e.weight))) return null;
        return {
          id: `e${index}`,
          source: `${sourceNode.id || nodes.indexOf(sourceNode)}`,
          target: `${targetNode.id || nodes.indexOf(targetNode)}`,
          label: String(e.weight),
          style: {
            stroke: currentTheme.edgeColor,
            strokeWidth: 3,
            filter: "drop-shadow(0 2px 4px rgba(0,0,0,0.1))"
          },
          labelStyle: {
            fill: currentTheme.edgeColor,
            fontWeight: "600",
            fontSize: "14px",
            fontFamily: "Inter, sans-serif"
          },
          labelBgStyle: {
            fill: theme === "light" ? "#ffffff" : "#1e293b",
            fillOpacity: 0.9,
            stroke: currentTheme.edgeColor,
            strokeWidth: 1,
            rx: 6,
            ry: 6
          },
          type: "smoothstep",
          markerEnd: {
            type: "arrowclosed",
            color: currentTheme.edgeColor,
            width: 20,
            height: 20
          },
        };
      })
      .filter((edge) => edge !== null);
  }, [edges, nodes, currentTheme, theme]);

  const renderInitialMatrix = () => {
    if (!initialMatrix || initialMatrix.length === 0 || !nodeNames || nodeNames.length === 0) return null;
    return (
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5, delay: 0.3 }}
        className="matrix-display"
      >
        <div className="matrix-header">
          <h3>Matrice Initiale (Dâ‚)</h3>
          <p>ReprÃ©sentation matricielle du graphe</p>
        </div>
        <div className="matrix-table-container">
          <table className="display-matrix">
            <thead>
              <tr>
                <th className="matrix-corner"></th>
                {nodeNames.map((name, index) => (
                  <th key={index} className="matrix-col-header">{name}</th>
                ))}
              </tr>
            </thead>
            <tbody>
              {initialMatrix.map((row, i) => (
                <tr key={i}>
                  <td className="matrix-row-header">{nodeNames[i]}</td>
                  {row.map((value, j) => (
                    <td key={j} className={`matrix-value ${i === j ? 'diagonal' : ''}`}>
                      {value === null ? <span className="infinity">âˆž</span> : value}
                    </td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </motion.div>
    );
  };

  return (
    <div className="graph-visualizer">
      <div className="panel-header">
        <div className="panel-icon">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
          </svg>
        </div>
        <div className="panel-title">
          <h2>Visualisation Interactive</h2>
          <p>ReprÃ©sentation graphique de votre rÃ©seau</p>
        </div>
      </div>

      {normalizedNodes.length === 0 && reactFlowEdges.length === 0 ? (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          className="empty-visualization"
        >
          <div className="empty-icon">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
            </svg>
          </div>
          <h3>Aucun graphe Ã  visualiser</h3>
          <p>CrÃ©ez ou sÃ©lectionnez un graphe pour voir sa reprÃ©sentation</p>
        </motion.div>
      ) : (
        <motion.div
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ duration: 0.5 }}
          className="visualization-content"
        >
          <div
            className="react-flow-container"
            style={{ background: currentTheme.background }}
          >
            <ReactFlow
              nodes={normalizedNodes}
              edges={reactFlowEdges}
              nodeTypes={nodeTypes}
              fitView
              fitViewOptions={{ padding: 0.3 }}
              nodesDraggable={true}
              className="react-flow-custom"
            >
              <Background
                color={theme === "light" ? "#e2e8f0" : "#334155"}
                gap={20}
                size={1}
                variant="dots"
              />
              <Controls className="react-flow-controls" />
              <MiniMap
                className="react-flow-minimap"
                nodeColor={(node) => {
                  const nodeData = normalizedNodes.find(n => n.id === node.id);
                  return nodeData?.data.gradient || currentTheme.nodeNormal;
                }}
              />
            </ReactFlow>
          </div>

          <div className="legend">
            <div className="legend-item">
              <div className="legend-node initial"></div>
              <span>Sommet Initial</span>
            </div>
            <div className="legend-item">
              <div className="legend-node normal"></div>
              <span>Sommet Normal</span>
            </div>
            <div className="legend-item">
              <div className="legend-node final"></div>
              <span>Sommet Final</span>
            </div>
          </div>

          {renderInitialMatrix()}
        </motion.div>
      )}
    </div>
  );
}

export default GraphVisualizer;
D:\...\frontend> 
D:\...\frontend> cat .\src\components\Header.jsx         
import { motion, AnimatePresence } from "framer-motion";

function Header({ theme, toggleTheme }) {
  return (
    <motion.header
      initial={{ opacity: 0, y: -20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.6 }}
      className="header"
    >
      <div className="header-content">
        <motion.div
          className="logo-container"
          whileHover={{ scale: 1.02 }}
          transition={{ type: "spring", stiffness: 400, damping: 10 }}
        >
          <div className="logo-icon">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
            <motion.div
              className="logo-pulse"
              animate={{ scale: [1, 1.2, 1], opacity: [0.5, 0.8, 0.5] }}
              transition={{ duration: 3, repeat: Infinity }}
            />
          </div>
          <div className="logo-text">
            <h1>Demoucron</h1>
            <p>Recherche OpÃ©rationnelle</p>
          </div>
        </motion.div>

        <div className="header-actions">
          <motion.button
            onClick={toggleTheme}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            className="theme-toggle"
          >
            <AnimatePresence mode="wait">
              {theme === "light" ? (
                <motion.div
                  key="dark"
                  initial={{ rotate: -90, opacity: 0 }}
                  animate={{ rotate: 0, opacity: 1 }}
                  exit={{ rotate: 90, opacity: 0 }}
                  transition={{ duration: 0.2 }}
                  className="theme-icon"
                >
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                  </svg>
                </motion.div>
              ) : (
                <motion.div
                  key="light"
                  initial={{ rotate: 90, opacity: 0 }}
                  animate={{ rotate: 0, opacity: 1 }}
                  exit={{ rotate: -90, opacity: 0 }}
                  transition={{ duration: 0.2 }}
                  className="theme-icon"
                >
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                  </svg>
                </motion.div>
              )}
            </AnimatePresence>
          </motion.button>
        </div>
      </div>
    </motion.header>
  );
}

export default Header;
D:\...\frontend> cat .\src\components\MatrixInput.jsx
import { useState } from "react";
import { motion } from "framer-motion";

function MatrixInput({ onMatrixUpdate, theme }) {
  const [nbrMatrice, setNbrMatrice] = useState(0);
  const [matrix, setMatrix] = useState([]);

  const handleChange = (e) => {
    const value = parseInt(e.target.value, 10);
    setNbrMatrice(value);
    if (value > 0) {
      const newMatrix = Array(value).fill().map(() => Array(value).fill(null));
      setMatrix(newMatrix);
      const node_names = Array.from({ length: value }, (_, i) => (i + 1).toString());
      onMatrixUpdate({ matrix: newMatrix, node_names });
    } else {
      setMatrix([]);
      onMatrixUpdate(null);
    }
  };

  const handleMatrixChange = (i, j, value) => {
    const newValue = value === "" ? null : parseFloat(value);
    const newMatrix = matrix.map((row, rowIndex) =>
      rowIndex === i ? row.map((cell, colIndex) => (colIndex === j ? newValue : cell)) : row
    );
    setMatrix(newMatrix);
    const node_names = Array.from({ length: nbrMatrice }, (_, i) => (i + 1).toString());
    onMatrixUpdate({ matrix: newMatrix, node_names });
  };

  return (
    <div className="matrix-input">
      <div className="panel-header">
        <div className="panel-icon">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
          </svg>
        </div>
        <div className="panel-title">
          <h2>EntrÃ©e Matricielle</h2>
          <p>Saisissez directement la matrice d'adjacence</p>
        </div>
      </div>

      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="matrix-config"
      >
        <div className="form-group">
          <label>Nombre de sommets</label>
          <div className="size-selector">
            <input
              type="number"
              value={nbrMatrice}
              onChange={handleChange}
              min="0"
              max="10"
              className="form-input size-input"
            />
            <div className="size-info">
              <span>Matrice {nbrMatrice}Ã—{nbrMatrice}</span>
            </div>
          </div>
        </div>
      </motion.div>

      {nbrMatrice > 0 && (
        <motion.div
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ duration: 0.5, delay: 0.2 }}
          className="matrix-container"
        >
          <div className="matrix-wrapper">
            <table className="matrix-table">
              <thead>
                <tr>
                  <th className="matrix-corner"></th>
                  {Array.from({ length: nbrMatrice }, (_, i) => (
                    <th key={i} className="matrix-header">{i + 1}</th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {matrix.map((row, i) => (
                  <tr key={i}>
                    <td className="matrix-header row-header">{i + 1}</td>
                    {row.map((cell, j) => (
                      <td key={j} className="matrix-cell">
                        <input
                          type="number"
                          value={cell === null ? "" : cell}
                          onChange={(e) => handleMatrixChange(i, j, e.target.value)}
                          className="matrix-input"
                          placeholder={i === j ? "0" : "âˆž"}
                        />
                      </td>
                    ))}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>

          <div className="matrix-legend">
            <div className="legend-item">
              <div className="legend-color diagonal"></div>
              <span>Diagonale (distance Ã  soi-mÃªme)</span>
            </div>
            <div className="legend-item">
              <div className="legend-color infinity"></div>
              <span>Vide = âˆž (pas de connexion directe)</span>
            </div>
            <div className="legend-item">
              <div className="legend-color value"></div>
              <span>Valeur = distance/poids</span>
            </div>
          </div>
        </motion.div>
      )}
    </div>
  );
}

export default MatrixInput;
D:\...\frontend> cat .\src\components\WijGraph.jsx   
"use client"

import { useEffect, useState } from "react"
import ReactFlow, { Controls, Background } from "reactflow"
import "reactflow/dist/style.css"
import { motion } from "framer-motion"

function WijGraph({ W, k, currentMatrix, stepIndex, nodes, nodeNames }) {
  const [isAnimating, setIsAnimating] = useState(false)

  const generateWijGraph = (W, k, currentMatrix, nodes, nodeNames) => {
    const rfNodes = []
    const rfEdges = []
    const uniqueNodes = new Set()
    const uniqueEdges = new Set()

    if (!W || W.length === 0 || !k || !currentMatrix || !nodeNames) {
      return { nodes: [], edges: [] }
    }

    const kNodeId = `node-${k - 1}`
    uniqueNodes.add(kNodeId)

    W.forEach(({ i, j }) => {
      uniqueNodes.add(`node-${i - 1}`)
      uniqueNodes.add(`node-${j - 1}`)

      const iIdx = i - 1
      const jIdx = j - 1
      const kIdx = k - 1

      // ArÃªte i -> k
      const edgeIkId = `edge-${iIdx}-${kIdx}-${stepIndex}`
      if (!uniqueEdges.has(edgeIkId) && iIdx < currentMatrix.length && kIdx < currentMatrix.length) {
        uniqueEdges.add(edgeIkId)
        const weightIk = currentMatrix[iIdx][kIdx]
        if (weightIk !== null && weightIk !== Number.POSITIVE_INFINITY) {
          rfEdges.push({
            id: edgeIkId,
            source: `node-${iIdx}`,
            target: `node-${kIdx}`,
            label: `${weightIk}`,
            animated: isAnimating,
            style: { stroke: "#3b82f6", strokeWidth: 3 },
            labelStyle: {
              fill: "#3b82f6",
              fontWeight: "600",
              fontSize: "12px",
              fontFamily: "Inter, sans-serif",
            },
            labelBgStyle: {
              fill: "white",
              fillOpacity: 0.9,
              stroke: "#3b82f6",
              strokeWidth: 1,
              rx: 4,
              ry: 4,
            },
          })
        }
      }

      // ArÃªte k -> j
      const edgeKjId = `edge-${kIdx}-${jIdx}-${stepIndex}`
      if (!uniqueEdges.has(edgeKjId) && kIdx < currentMatrix.length && jIdx < currentMatrix.length) {
        uniqueEdges.add(edgeKjId)
        const weightKj = currentMatrix[kIdx][jIdx]
        if (weightKj !== null && weightKj !== Number.POSITIVE_INFINITY) {
          rfEdges.push({
            id: edgeKjId,
            source: `node-${kIdx}`,
            target: `node-${jIdx}`,
            label: `${weightKj}`,
            animated: isAnimating,
            style: { stroke: "#06b6d4", strokeWidth: 3 },
            labelStyle: {
              fill: "#06b6d4",
              fontWeight: "600",
              fontSize: "12px",
              fontFamily: "Inter, sans-serif",
            },
            labelBgStyle: {
              fill: "white",
              fillOpacity: 0.9,
              stroke: "#06b6d4",
              strokeWidth: 1,
              rx: 4,
              ry: 4,
            },
          })
        }
      }
    })

    uniqueNodes.forEach((nodeId) => {
      const nodeIndex = Number.parseInt(nodeId.split("-")[1])
      const nodeName = nodeNames[nodeIndex] || `${nodeIndex + 1}`
      const isKNode = nodeId === kNodeId
      rfNodes.push({
        id: nodeId,
        data: { label: nodeName },
        position: { x: nodeIndex * 120 + 50, y: isKNode ? 50 : 150 },
        style: isKNode
          ? {
              background: "linear-gradient(135deg, #f59e0b, #f97316)",
              color: "white",
              borderRadius: "50%",
              width: "50px",
              height: "50px",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              fontWeight: "bold",
              fontSize: "16px",
              boxShadow: "0 8px 25px rgba(245, 158, 11, 0.4)",
              border: "3px solid #fbbf24",
            }
          : {
              background: "linear-gradient(135deg, #3b82f6, #06b6d4)",
              color: "white",
              borderRadius: "50%",
              width: "45px",
              height: "45px",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              fontWeight: "bold",
              fontSize: "14px",
              boxShadow: "0 6px 20px rgba(59, 130, 246, 0.3)",
            },
      })
    })

    return { nodes: rfNodes, edges: rfEdges }
  }

  const { nodes: initialNodes, edges: initialEdges } = generateWijGraph(W, k, currentMatrix, nodes, nodeNames)
  const [rfNodes, setNodes] = useState(initialNodes)
  const [rfEdges, setEdges] = useState(initialEdges)

  useEffect(() => {
    const { nodes: newNodes, edges: newEdges } = generateWijGraph(W, k, currentMatrix, nodes, nodeNames)
    setNodes(newNodes)
    setEdges(newEdges)
  }, [W, k, currentMatrix, nodes, nodeNames, isAnimating])

  return (
    <div className="wij-graph">
      {rfNodes.length > 0 ? (
        <div className="wij-container">
          <ReactFlow nodes={rfNodes} edges={rfEdges} fitView fitViewOptions={{ padding: 0.2 }}>
            <Background color="#f0f0f0" gap={16} size={1} variant="dots" />
            <Controls />
          </ReactFlow>
          <motion.button
            onClick={() => setIsAnimating(!isAnimating)}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            className="animation-toggle"
          >
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d={
                  isAnimating
                    ? "M10 9v6m4-6v6"
                    : "M14.828 14.828a4 4 0 01-5.656 0M9 10h1.586a1 1 0 01.707.293l2.414 2.414a1 1 0 00.707.293H15"
                }
              />
            </svg>
            {isAnimating ? "Pause" : "Animer"}
          </motion.button>
        </div>
      ) : (
        <div className="wij-empty">
          <div className="empty-icon">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M13.828 10.172a4 0 00-5.656 0l-4 4a4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 0 005.5 0l4-4a4 0 00-5.656-5.656l-1.1 1.1"
              />
            </svg>
          </div>
          <p>Aucun chemin trouvÃ© pour cette Ã©tape</p>
        </div>
      )}
    </div>
  )
}

export default WijGraph
D:\...\frontend> 
D:\...\frontend> cat .\src\components\ResultsDisplay.jsx
"use client"

import React, { useState } from "react"
import { motion, AnimatePresence } from "framer-motion"
import WijGraph from "./WijGraph.jsx"

function MatrixDisplay({ matrix, nodeNames, title, optimalPaths = {} }) {
  if (!matrix || !nodeNames) {
    return <p className="empty-state">Matrice non disponible</p>
  }

  // Identifier les valeurs optimales
  const isOptimalValue = Array(matrix.length)
    .fill()
    .map(() => Array(matrix.length).fill(false))
  Object.entries(optimalPaths).forEach(([_, path]) => {
    if (path && path.length > 1) {
      for (let k = 0; k < path.length - 1; k++) {
        const i = path[k] - 1
        const j = path[k + 1] - 1
        if (i >= 0 && j >= 0 && i < matrix.length && j < matrix.length) {
          isOptimalValue[i][j] = true
        }
      }
    }
  })

  return (
    <div className="matrix-display-container">
      {title && <h4 className="matrix-title">{title}</h4>}
      <div className="matrix-table-wrapper">
        <table className="result-matrix">
          <thead>
            <tr>
              <th className="matrix-corner"></th>
              {nodeNames.map((name, index) => (
                <th key={index} className="matrix-header">
                  {name}
                </th>
              ))}
            </tr>
          </thead>
          <tbody>
            {matrix.map((row, i) => (
              <tr key={i}>
                <td className="matrix-row-header">{nodeNames[i]}</td>
                {row.map((value, j) => (
                  <td
                    key={j}
                    className={`matrix-cell ${i === j ? "diagonal" : ""} ${isOptimalValue[i][j] ? "optimal" : ""}`}
                  >
                    {value === Number.POSITIVE_INFINITY ? <span className="infinity">âˆž</span> : value}
                  </td>
                ))}
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  )
}

function CalculationsDisplay({ calculations, type, method }) {
  if (!calculations || calculations.length === 0) {
    return <p className="empty-state">Aucun calcul disponible</p>
  }

  return (
    <div className="calculation-section">
      <h4 className="calculation-title">
        Calculs {type} ({method === "min" ? "Minimisation" : "Maximisation"})
      </h4>
      <div className="calculation-list">
        {calculations.map((calc, index) => (
          <div key={index} className="calculation-item">
            <div className="calculation-formula" dangerouslySetInnerHTML={{ __html: calc.formula }} />
          </div>
        ))}
      </div>
    </div>
  )
}

function ResultsDisplay({ results, theme, nodes, nodeNames }) {
  const [expandedSteps, setExpandedSteps] = useState({})
  const [activeTab, setActiveTab] = useState("steps")

  if (!results || results.error) {
    const error = results?.error || "Aucun rÃ©sultat disponible"
    return (
      <div className="results-error">
        <div className="error-icon">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
            />
          </svg>
        </div>
        <h3>Erreur de calcul</h3>
        <p>{error}</p>
      </div>
    )
  }

  const { steps, finalMatrix, optimalPaths, method } = results

  const toggleStep = (index) => {
    setExpandedSteps((prev) => ({ ...prev, [index]: !prev[index] }))
  }

  return (
    <div className="results-display">
      <div className="results-header">
        <div className="results-icon">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"
            />
          </svg>
        </div>
        <div className="results-title">
          <h2>RÃ©sultats de l'Algorithme</h2>
          <p>
            Analyse complÃ¨te des chemins optimaux avec la mÃ©thode de{" "}
            {method === "min" ? "minimisation" : "maximisation"}
          </p>
        </div>
      </div>

      <div className="results-tabs">
        <button onClick={() => setActiveTab("steps")} className={`tab-btn ${activeTab === "steps" ? "active" : ""}`}>
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
          </svg>
          Ã‰tapes de Calcul
        </button>
        <button onClick={() => setActiveTab("final")} className={`tab-btn ${activeTab === "final" ? "active" : ""}`}>
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"
            />
          </svg>
          RÃ©sultat Final
        </button>
        <button onClick={() => setActiveTab("paths")} className={`tab-btn ${activeTab === "paths" ? "active" : ""}`}>
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M13.828 10.172a4 0 00-5.656 0l-4 4a4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 0 005.5 0l4-4a4 0 00-5.656-5.656l-1.1 1.1"
            />
          </svg>
          Chemins Optimaux
        </button>
      </div>

      <AnimatePresence mode="wait">
        {activeTab === "steps" && (
          <motion.div
            key="steps"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            transition={{ duration: 0.3 }}
            className="tab-content"
          >
            <div className="steps-container">
              {steps &&
                steps.map((step, index) => (
                  <motion.div
                    key={index}
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ duration: 0.3, delay: index * 0.1 }}
                    className="step-card"
                  >
                    <button onClick={() => toggleStep(index)} className="step-header">
                      <div className="step-info">
                        <div className="step-number">{step.k}</div>
                        <div className="step-details">
                          <h4>{step.description}</h4>
                          <p>
                            {step.k === 0
                              ? "Configuration initiale de la matrice"
                              : `Calculs avec le nÅ“ud intermÃ©diaire ${step.k}`}
                          </p>
                        </div>
                      </div>
                      <div className={`step-toggle ${expandedSteps[index] ? "expanded" : ""}`}>
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                        </svg>
                      </div>
                    </button>

                    <AnimatePresence>
                      {expandedSteps[index] && (
                        <motion.div
                          initial={{ height: 0, opacity: 0 }}
                          animate={{ height: "auto", opacity: 1 }}
                          exit={{ height: 0, opacity: 0 }}
                          transition={{ duration: 0.3 }}
                          className="step-content"
                        >
                          <div className="step-grid">
                            <div className="step-matrix">
                              <MatrixDisplay matrix={step.matrix} nodeNames={nodeNames} title={`Matrice D${step.k}`} />
                            </div>
                            {step.k > 0 && (
                              <div className="step-graph">
                                <h5>Graphe W{step.k}</h5>
                                <WijGraph
                                  W={step.W || []}
                                  k={step.k}
                                  currentMatrix={step.matrix}
                                  stepIndex={index}
                                  nodes={nodes}
                                  nodeNames={nodeNames}
                                />
                              </div>
                            )}
                          </div>
                          {step.k > 0 && (
                            <div className="calculations-grid">
                              <CalculationsDisplay calculations={step.W} type="W" method={method} />
                              <CalculationsDisplay calculations={step.V} type="V" method={method} />
                            </div>
                          )}
                        </motion.div>
                      )}
                    </AnimatePresence>
                  </motion.div>
                ))}
            </div>
          </motion.div>
        )}

        {activeTab === "final" && (
          <motion.div
            key="final"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            transition={{ duration: 0.3 }}
            className="tab-content"
          >
            <div className="final-result">
              <div className="final-header">
                <h3>Matrice Finale</h3>
                <p>RÃ©sultat aprÃ¨s application complÃ¨te de l'algorithme de Demoucron</p>
              </div>
              <MatrixDisplay matrix={finalMatrix} nodeNames={nodeNames} optimalPaths={optimalPaths} />
            </div>
          </motion.div>
        )}

        {activeTab === "paths" && (
          <motion.div
            key="paths"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            transition={{ duration: 0.3 }}
            className="tab-content"
          >
            <div className="paths-result">
              <div className="paths-header">
                <h3>Chemins Optimaux</h3>
                <p>
                  Meilleurs chemins trouvÃ©s selon la mÃ©thode de {method === "min" ? "minimisation" : "maximisation"}
                </p>
              </div>
              {optimalPaths && Object.keys(optimalPaths).length > 0 ? (
                <div className="optimal-paths-grid">
                  {Object.entries(optimalPaths).map(([key, path]) => {
                    const [start, end] = key.split("-")
                    return (
                      <div key={key} className="path-card">
                        <div className="path-info">
                          <div className="path-nodes">
                            <span className="path-start">{nodeNames[start - 1]}</span>
                            <svg className="path-arrow" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path
                                strokeLinecap="round"
                                strokeLinejoin="round"
                                strokeWidth={2}
                                d="M17 8l4 4m0 0l-4 4m4-4H3"
                              />
                            </svg>
                            <span className="path-end">{nodeNames[end - 1]}</span>
                          </div>
                          <div className="path-sequence">
                            {path.map((node, index) => (
                              <React.Fragment key={index}>
                                <span className="path-node">{nodeNames[node - 1]}</span>
                                {index < path.length - 1 && (
                                  <svg className="path-connector" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path
                                      strokeLinecap="round"
                                      strokeLinejoin="round"
                                      strokeWidth={2}
                                      d="M9 5l7 7-7 7"
                                    />
                                  </svg>
                                )}
                              </React.Fragment>
                            ))}
                          </div>
                          <div className="path-cost">
                            CoÃ»t:{" "}
                            {finalMatrix[start - 1][end - 1] === Number.POSITIVE_INFINITY
                              ? "âˆž"
                              : finalMatrix[start - 1][end - 1]}
                          </div>
                        </div>
                      </div>
                    )
                  })}
                </div>
              ) : (
                <div className="no-path">
                  <div className="no-path-icon">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.464 0L3.34 16.5c-.77.833.192 2.5 1.732 2.5z"
                      />
                    </svg>
                  </div>
                  <h4>Aucun chemin optimal trouvÃ©</h4>
                  <p>VÃ©rifiez votre matrice d'entrÃ©e</p>
                </div>
              )}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  )
}

export default ResultsDisplay
