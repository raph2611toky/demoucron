
---

### Project Structure

The combined frontend will reside in the `frontend` directory, incorporating components and styles from both original frontends. Here’s the updated structure:

```
D:\TOKY\PROJET\Recherche operationnel\demoucron\frontend\
├── node_modules/
├── public/
│   └── (existing files like index.html, favicon.ico)
├── src/
│   ├── App.jsx              # Main application component with mode switching
│   ├── index.jsx           # Entry point
│   ├── styles.css          # Updated styles incorporating both frontends
│   ├── assets/
│   │   └── react.svg
│   └── components/
│       ├── GraphEditor.jsx  # Modified to update graph data only
│       ├── GraphVisualizer.jsx  # Existing, adjusted for both modes
│       ├── Header.jsx       # Existing, unchanged
│       ├── ResultsDisplay.jsx  # Existing, adjusted for matrix mode
│       ├── WijGraph.jsx     # Existing, adjusted for compatibility
│       └── MatrixInput.jsx  # New component for matrix input
├── package.json
├── vite.config.js
└── (other config files like .gitignore, eslint.config.js)
```

---
### Frontend Code (Updated and New Files)

#### `src/App.jsx`

```jsx
import { useState, useCallback, useEffect } from "react";
import { motion } from "framer-motion";
import axios from "axios";
import Header from "./components/Header.jsx";
import GraphEditor from "./components/GraphEditor.jsx";
import MatrixInput from "./components/MatrixInput.jsx";
import GraphVisualizer from "./components/GraphVisualizer.jsx";
import ResultsDisplay from "./components/ResultsDisplay.jsx";
import "./styles.css";

function App() {
  const [mode, setMode] = useState("graph");
  const [theme, setTheme] = useState("light");
  const [visualizationData, setVisualizationData] = useState({
    nodes: [],
    edges: [],
    node_names: [],
    initial_matrix: []
  });
  const [calculationData, setCalculationData] = useState(null);
  const [results, setResults] = useState(null);
  const [method, setMethod] = useState("min");

  useEffect(() => {
    if (theme === "dark") {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }
  }, [theme]);

  useEffect(() => {
    setVisualizationData({ nodes: [], edges: [], node_names: [], initial_matrix: [] });
    setCalculationData(null);
    setResults(null);
  }, [mode]);

  const toggleTheme = useCallback(() => {
    setTheme(theme === "light" ? "dark" : "light");
  }, [theme]);

  const handleGraphUpdate = useCallback((data) => {
    setVisualizationData({
      nodes: data.nodes || [],
      edges: data.edges || [],
      node_names: data.node_names || [],
      initial_matrix: data.initial_matrix || []
    });
    setCalculationData({ type: "graph", graphId: data.graphId });
  }, []);

  const handleMatrixUpdate = useCallback((data) => {
    if (data) {
      const { matrix, node_names } = data;
      const nodes = node_names.map((name, index) => ({ id: index, name, type: "normal" }));
      const edges = [];
      for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[i].length; j++) {
          if (matrix[i][j] !== null && i !== j) {
            edges.push({ source: node_names[i], target: node_names[j], weight: matrix[i][j] });
          }
        }
      }
      setVisualizationData({ nodes, edges, node_names, initial_matrix: matrix });
      setCalculationData({ type: "matrix", matrix, node_names });
    } else {
      setVisualizationData({ nodes: [], edges: [], node_names: [], initial_matrix: [] });
      setCalculationData(null);
    }
  }, []);

  const handleCalculate = async () => {
    if (!calculationData) return;
    try {
      let response;
      if (calculationData.type === "graph" && calculationData.graphId) {
        response = await axios.get(`http://localhost:8000/api/graphs/${calculationData.graphId}/run_demoucron/?mode=${method}`);
      } else if (calculationData.type === "matrix" && calculationData.matrix) {
        response = await axios.post("http://localhost:8000/api/matrix_demoucron/", {
          matrix: calculationData.matrix,
          node_names: calculationData.node_names,
          method: method
        });
      }
      setResults(response.data);
    } catch (error) {
      console.error("Calculation error:", error);
      setResults({ error: "Erreur lors du calcul" });
    }
  };

  const canCalculate = calculationData && (calculationData.type === "graph" ? calculationData.graphId : calculationData.matrix && calculationData.matrix.length > 0);

  return (
    <div className="app-container">
      <Header theme={theme} toggleTheme={toggleTheme} />
      <main className="main-content">
        <motion.div
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.6 }}
          className="hero-section"
        >
          <h1 className="hero-title">Algorithme de Demoucron</h1>
          <p className="hero-description">
            Créez un graphe ou entrez une matrice, puis calculez les chemins optimaux avec l'algorithme de Demoucron.
          </p>
        </motion.div>

        <div className="mode-selector">
          <button onClick={() => setMode("graph")} className={mode === "graph" ? "active" : ""}>Éditeur de Graphe</button>
          <button onClick={() => setMode("matrix")} className={mode === "matrix" ? "active" : ""}>Entrée Matricielle</button>
        </div>

        <div className="grid xl:grid-cols-2 gap-8 mb-8">
          {mode === "graph" && (
            <motion.div
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ duration: 0.6, delay: 0.1 }}
              className="card"
            >
              <GraphEditor onUpdate={handleGraphUpdate} theme={theme} />
            </motion.div>
          )}
          {mode === "matrix" && (
            <motion.div
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ duration: 0.6, delay: 0.1 }}
              className="card"
            >
              <MatrixInput onMatrixUpdate={handleMatrixUpdate} theme={theme} />
            </motion.div>
          )}
          <motion.div
            initial={{ opacity: 0, x: 20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ duration: 0.6, delay: 0.2 }}
            className="card"
          >
            <GraphVisualizer
              nodes={visualizationData.nodes}
              edges={visualizationData.edges}
              theme={theme}
              nodeNames={visualizationData.node_names}
              initialMatrix={visualizationData.initial_matrix}
            />
          </motion.div>
        </div>

        <div className="method-selection card p-6 mb-8">
          <h3 className="section-title">Méthode de Calcul</h3>
          <div className="flex gap-6">
            <label className="flex items-center gap-3 cursor-pointer">
              <input
                type="radio"
                value="min"
                checked={method === "min"}
                onChange={() => setMethod("min")}
                className="radio-input"
              />
              <div className="flex items-center gap-2">
                <svg className="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 14l-7 7m0 0l-7-7m7 7V3" />
                </svg>
                <span className="font-medium">Minimisation</span>
              </div>
            </label>
            <label className="flex items-center gap-3 cursor-pointer">
              <input
                type="radio"
                value="max"
                checked={method === "max"}
                onChange={() => setMethod("max")}
                className="radio-input"
              />
              <div className="flex items-center gap-2">
                <svg className="w-5 h-5 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 10l7-7m0 0l7 7m-7-7v18" />
                </svg>
                <span className="font-medium">Maximisation</span>
              </div>
            </label>
          </div>
          <motion.button
            onClick={handleCalculate}
            disabled={!canCalculate}
            whileHover={{ scale: canCalculate ? 1.02 : 1 }}
            whileTap={{ scale: canCalculate ? 0.98 : 1 }}
            className="btn btn-gradient mt-4 w-full"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
            Calculer les Chemins Optimaux
          </motion.button>
        </div>

        {results && (
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.6, delay: 0.3 }}
            className="card"
          >
            <ResultsDisplay
              results={results}
              theme={theme}
              nodes={visualizationData.nodes}
              edges={visualizationData.edges}
              nodeNames={visualizationData.node_names}
            />
          </motion.div>
        )}
      </main>
    </div>
  );
}

export default App;
```

#### `src/index.jsx`

```jsx
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.jsx";
import "./styles.css";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

#### `src/components/GraphEditor.jsx`

```jsx
import { useState, useEffect, useCallback } from "react";
import { motion, AnimatePresence } from "framer-motion";
import axios from "axios";

function GraphEditor({ onUpdate, theme }) {
  const [graphId, setGraphId] = useState(null);
  const [graphName, setGraphName] = useState("");
  const [graphs, setGraphs] = useState([]);
  const [selectedGraph, setSelectedGraph] = useState("");
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);
  const [nodeName, setNodeName] = useState("");
  const [nodeType, setNodeType] = useState("normal");
  const [source, setSource] = useState("");
  const [target, setTarget] = useState("");
  const [weight, setWeight] = useState("");
  const [loading, setLoading] = useState(false);
  const [notification, setNotification] = useState({ show: false, message: "", type: "success" });

  const loadGraphs = useCallback(async () => {
    setLoading(true);
    try {
      const response = await axios.get("http://localhost:8000/api/graphs/");
      setGraphs(response.data);
    } catch (error) {
      setNotification({ show: true, message: `Erreur de connexion: ${error.message}`, type: "error" });
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    loadGraphs();
  }, [loadGraphs]);

  const loadGraphDetails = useCallback(async (graphId) => {
    if (!graphId) {
      setGraphId(null);
      setNodes([]);
      setEdges([]);
      onUpdate({ nodes: [], edges: [], node_names: [], initial_matrix: [], graphId: null });
      return;
    }
    setLoading(true);
    try {
      const response = await axios.get(`http://localhost:8000/api/graphs/${graphId}/`);
      const data = response.data;
      setGraphId(data.id);
      setNodes(data.sommets || []);
      setEdges(data.arcs || []);
      setNotification({ show: true, message: `Graphe '${data.name}' chargé avec succès`, type: "success" });
      onUpdate({
        nodes: data.sommets || [],
        edges: data.arcs || [],
        node_names: data.node_names || [],
        initial_matrix: data.initial_matrix || [],
        graphId: data.id
      });
    } catch (error) {
      setNotification({ show: true, message: `Erreur de connexion: ${error.message}`, type: "error" });
      onUpdate({ error: "Erreur lors du chargement du graphe" });
    } finally {
      setLoading(false);
    }
  }, [onUpdate]);

  useEffect(() => {
    loadGraphDetails(selectedGraph);
  }, [selectedGraph, loadGraphDetails]);

  const createGraph = async () => {
    if (!graphName) {
      setNotification({ show: true, message: "Veuillez entrer un nom pour le graphe", type: "error" });
      return;
    }
    setLoading(true);
    try {
      const response = await axios.post("http://localhost:8000/api/graphs/create/", { name: graphName });
      const newGraph = response.data;
      setGraphs((prevGraphs) => [...prevGraphs, newGraph]);
      setSelectedGraph(String(newGraph.id));
      setGraphName("");
      setNotification({ show: true, message: `Graphe '${newGraph.name}' créé avec succès`, type: "success" });
    } catch (error) {
      setNotification({ show: true, message: `Erreur de connexion: ${error.message}`, type: "error" });
    } finally {
      setLoading(false);
    }
  };

  const addNode = async () => {
    if (!nodeName) {
      setNotification({ show: true, message: "Veuillez entrer un nom pour le sommet", type: "error" });
      return;
    }
    if (!graphId) {
      setNotification({ show: true, message: "Veuillez créer ou sélectionner un graphe d'abord", type: "error" });
      return;
    }
    if (nodes.some((n) => n.name === nodeName)) {
      setNotification({ show: true, message: `Le sommet '${nodeName}' existe déjà`, type: "error" });
      return;
    }
    setLoading(true);
    try {
      await axios.post(`http://localhost:8000/api/graphs/${graphId}/add_sommet/`, { name: nodeName, type: nodeType });
      await loadGraphDetails(graphId);
      setNodeName("");
      setNodeType("normal");
      setNotification({ show: true, message: `Sommet '${nodeName}' ajouté avec succès`, type: "success" });
    } catch (error) {
      setNotification({ show: true, message: `Erreur de connexion: ${error.message}`, type: "error" });
    } finally {
      setLoading(false);
    }
  };

  const addEdge = async () => {
    if (!source || !target || !weight) {
      setNotification({ show: true, message: "Veuillez remplir tous les champs pour l'arc", type: "error" });
      return;
    }
    if (!graphId) {
      setNotification({ show: true, message: "Veuillez créer ou sélectionner un graphe d'abord", type: "error" });
      return;
    }
    if (source === target) {
      setNotification({ show: true, message: "La source et la cible ne peuvent pas être identiques", type: "error" });
      return;
    }
    setLoading(true);
    try {
      await axios.post(`http://localhost:8000/api/graphs/${graphId}/add_arc/`, {
        source,
        target,
        weight: Number.parseFloat(weight)
      });
      await loadGraphDetails(graphId);
      setSource("");
      setTarget("");
      setWeight("");
      setNotification({ show: true, message: `Arc de '${source}' à '${target}' ajouté avec succès`, type: "success" });
    } catch (error) {
      setNotification({ show: true, message: `Erreur de connexion: ${error.message}`, type: "error" });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (notification.show) {
      const timer = setTimeout(() => setNotification({ show: false, message: "", type: "success" }), 4000);
      return () => clearTimeout(timer);
    }
  }, [notification]);

  const getNodeTypeIcon = (type) => {
    switch (type) {
      case "initial":
        return <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 3h14a2 2 0 012 2v14a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2m4 7h6" /></svg>;
      case "final":
        return <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>;
      default:
        return <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" /></svg>;
    }
  };

  return (
    <div className="p-6">
      <div className="card-header flex items-center gap-3 mb-6">
        <div className="card-icon w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center">
          <svg className="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 4a2 2 0 114 0v4a1 1 0 001 1h3a1 1 0 011 1v3a1 1 0 01-1 1h-1a2 2 0 100 4h1a1 1 0 011 1v3a1 1 0 01-1 1h-3a1 1 0 01-1-1v-1a2 2 0 10-4 0v1a1 1 0 01-1 1H7a1 1 0 01-1-1v-3a1 1 0 00-1-1H4a1 1 0 01-1-1V9a1 1 0 011-1h1a2 2 0 100-4H4a1 1 0 01-1-1V4a1 1 0 011-1h3a1 1 0 001-1v-1a2 2 0 114 0z" />
          </svg>
        </div>
        <div>
          <h2 className="card-title text-2xl font-bold">Éditeur de Graphe</h2>
          <p className="card-subtitle text-sm text-gray-500">Créez et modifiez votre graphe pour l'analyse</p>
        </div>
      </div>

      <div className="space-y-6">
        <AnimatePresence>
          {notification.show && (
            <motion.div
              initial={{ opacity: 0, y: -10, scale: 0.95 }}
              animate={{ opacity: 1, y: 0, scale: 1 }}
              exit={{ opacity: 0, y: -10, scale: 0.95 }}
              transition={{ duration: 0.2 }}
              className={`p-4 rounded-lg border-l-4 ${notification.type === "error" ? "bg-red-50 border-red-400 text-red-700" : "bg-green-50 border-green-400 text-green-700"}`}
            >
              <div className="flex items-center gap-2">
                {notification.type === "error" ? (
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                ) : (
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                )}
                <span className="font-medium">{notification.message}</span>
              </div>
            </motion.div>
          )}
        </AnimatePresence>

        <div className="bg-gray-50 rounded-xl p-4">
          <div className="flex justify-between items-center mb-4">
            <h3 className="section-title text-lg font-semibold">Gestion du Graphe</h3>
            <button onClick={loadGraphs} disabled={loading} className="btn btn-secondary px-3 py-1 text-sm flex items-center gap-2">
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m0 0a8.001 8.001 0 0115.356 2m-15.356-2H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
              </svg>
              Rafraîchir
            </button>
          </div>
          <div className="grid md:grid-cols-2 gap-4">
            <div>
              <label className="form-label block text-sm font-medium mb-2">Sélectionner un graphe</label>
              <select value={selectedGraph} onChange={(e) => setSelectedGraph(e.target.value)} className="form-select w-full px-3 py-2 border rounded-lg">
                <option value="">Choisir un graphe existant</option>
                {graphs.map((g) => <option key={g.id} value={g.id}>{g.name}</option>)}
              </select>
            </div>
            <div>
              <label className="form-label block text-sm font-medium mb-2">Nouveau graphe</label>
              <div className="flex gap-2">
                <input type="text" value={graphName} onChange={(e) => setGraphName(e.target.value)} placeholder="Nom du graphe" className="form-input flex-1 px-3 py-2 border rounded-lg" />
                <button onClick={createGraph} disabled={loading} className="btn btn-primary px-4 py-2 bg-blue-600 text-white rounded-lg">
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                  </svg>
                </button>
              </div>
            </div>
          </div>
        </div>

        <div className="bg-gray-50 rounded-xl p-4">
          <h3 className="section-title text-lg font-semibold mb-4">Ajouter un Sommet</h3>
          <div className="grid md:grid-cols-3 gap-4">
            <div>
              <label className="form-label block text-sm font-medium mb-2">Nom du sommet</label>
              <input type="text" value={nodeName} onChange={(e) => setNodeName(e.target.value)} placeholder="Ex: A, B, C..." className="form-input w-full px-3 py-2 border rounded-lg" />
            </div>
            <div>
              <label className="form-label block text-sm font-medium mb-2">Type de sommet</label>
              <select value={nodeType} onChange={(e) => setNodeType(e.target.value)} className="form-select w-full px-3 py-2 border rounded-lg">
                <option value="normal">Normal</option>
                <option value="initial">Initial</option>
                <option value="final">Final</option>
              </select>
            </div>
            <div className="flex items-end">
              <button onClick={addNode} disabled={loading} className="btn btn-success w-full px-4 py-2 bg-green-600 text-white rounded-lg">
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                </svg>
                Ajouter
              </button>
            </div>
          </div>
        </div>

        <div className="bg-gray-50 rounded-xl p-4">
          <h3 className="section-title text-lg font-semibold mb-4">Ajouter un Arc</h3>
          <div className="grid md:grid-cols-4 gap-4">
            <div>
              <label className="form-label block text-sm font-medium mb-2">Source</label>
              <select value={source} onChange={(e) => setSource(e.target.value)} className="form-select w-full px-3 py-2 border rounded-lg">
                <option value="">Choisir</option>
                {nodes.map((n) => <option key={n.id} value={n.name}>{n.name}</option>)}
              </select>
            </div>
            <div>
              <label className="form-label block text-sm font-medium mb-2">Cible</label>
              <select value={target} onChange={(e) => setTarget(e.target.value)} className="form-select w-full px-3 py-2 border rounded-lg">
                <option value="">Choisir</option>
                {nodes.map((n) => <option key={n.id} value={n.name}>{n.name}</option>)}
              </select>
            </div>
            <div>
              <label className="form-label block text-sm font-medium mb-2">Poids</label>
              <input type="number" value={weight} onChange={(e) => setWeight(e.target.value)} placeholder="0" className="form-input w-full px-3 py-2 border rounded-lg" />
            </div>
            <div className="flex items-end">
              <button onClick={addEdge} disabled={loading} className="btn btn-purple w-full px-4 py-2 bg-purple-600 text-white rounded-lg">
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.828 10.172a4 0 00-5.656 0l-4 4a4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 0 005.5 0l4-4a4 0 00-5.656-5.656l-1.1 1.1" />
                </svg>
                Ajouter
              </button>
            </div>
          </div>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div className="bg-gray-50 rounded-xl p-4">
            <h3 className="section-title-sm text-lg font-semibold mb-3">Sommets ({nodes.length})</h3>
            <div className="space-y-2 max-h-32 overflow-y-auto">
              {nodes.length > 0 ? (
                nodes.map((n) => (
                  <div key={n.id} className="flex items-center gap-2">
                    <span className={`inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium border ${n.type === "initial" ? "bg-green-100 text-green-800 border-green-300" : n.type === "final" ? "bg-red-100 text-red-800 border-red-300" : "bg-blue-100 text-blue-800 border-blue-300"}`}>
                      {getNodeTypeIcon(n.type)}
                      {n.name}
                    </span>
                    <span className="text-xs text-gray-500">({n.type})</span>
                  </div>
                ))
              ) : (
                <p className="text-sm text-gray-500">Aucun sommet ajouté</p>
              )}
            </div>
          </div>

          <div className="bg-gray-50 rounded-xl p-4">
            <h3 className="section-title-sm text-lg font-semibold mb-3">Arcs ({edges.length})</h3>
            <div className="space-y-2 max-h-32 overflow-y-auto">
              {edges.length > 0 ? (
                edges.map((e, index) => (
                  <div key={index} className="flex items-center gap-2 text-sm">
                    <span className="px-2 py-1 bg-blue-100 text-blue-800 rounded text-xs font-medium">{e.source}</span>
                    <svg className="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 8l4 4m0 0l-4 4m4-4H3" />
                    </svg>
                    <span className="px-2 py-1 bg-blue-100 text-blue-800 rounded text-xs font-medium">{e.target}</span>
                    <span className="text-gray-500">({e.weight})</span>
                  </div>
                ))
              ) : (
                <p className="text-sm text-gray-500">Aucun arc ajouté</p>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

export default GraphEditor;
```

#### `src/components/MatrixInput.jsx` (New File)

```jsx
import { useState } from "react";

function MatrixInput({ onMatrixUpdate, theme }) {
  const [nbrMatrice, setNbrMatrice] = useState(0);
  const [matrix, setMatrix] = useState([]);

  const handleChange = (e) => {
    const value = parseInt(e.target.value, 10);
    setNbrMatrice(value);
    if (value > 0) {
      const newMatrix = Array(value).fill().map(() => Array(value).fill(null));
      setMatrix(newMatrix);
      const node_names = Array.from({ length: value }, (_, i) => (i + 1).toString());
      onMatrixUpdate({ matrix: newMatrix, node_names });
    } else {
      setMatrix([]);
      onMatrixUpdate(null);
    }
  };

  const handleMatrixChange = (i, j, value) => {
    const newValue = value === "" ? null : parseFloat(value);
    const newMatrix = matrix.map((row, rowIndex) =>
      rowIndex === i ? row.map((cell, colIndex) => (colIndex === j ? newValue : cell)) : row
    );
    setMatrix(newMatrix);
    const node_names = Array.from({ length: nbrMatrice }, (_, i) => (i + 1).toString());
    onMatrixUpdate({ matrix: newMatrix, node_names });
  };

  return (
    <div className="p-6">
      <div className="card-header flex items-center gap-3 mb-6">
        <div className="card-icon w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center">
          <svg className="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
          </svg>
        </div>
        <div>
          <h2 className="card-title text-2xl font-bold">Entrée Matricielle</h2>
          <p className="card-subtitle text-sm text-gray-500">Entrez manuellement la matrice d'adjacence</p>
        </div>
      </div>

      <div className="form-group">
        <label className="form-label block text-sm font-medium mb-2">Nombre de sommets :</label>
        <input
          type="number"
          value={nbrMatrice}
          onChange={handleChange}
          min="0"
          className="form-input w-32 px-3 py-2 border rounded-lg"
        />
      </div>

      {nbrMatrice > 0 && (
        <div className="mt-6 overflow-x-auto">
          <table className="border-collapse rounded-lg shadow-md">
            <thead>
              <tr className="bg-gradient-to-r from-blue-500 to-cyan-500">
                <th className="p-3 text-white"></th>
                {Array.from({ length: nbrMatrice }, (_, i) => (
                  <th key={i} className="p-3 text-white">{i + 1}</th>
                ))}
              </tr>
            </thead>
            <tbody>
              {matrix.map((row, i) => (
                <tr key={i} className={i % 2 === 0 ? "bg-gray-50" : "bg-white dark:bg-gray-800"}>
                  <td className="p-3 font-medium text-white bg-gradient-to-r from-blue-500 to-cyan-500">{i + 1}</td>
                  {row.map((cell, j) => (
                    <td key={j} className="p-3">
                      <input
                        type="number"
                        value={cell === null ? "" : cell}
                        onChange={(e) => handleMatrixChange(i, j, e.target.value)}
                        className="form-input w-20 px-2 py-1 border rounded-lg text-center"
                      />
                    </td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </div>
  );
}

export default MatrixInput;
```

#### `src/components/GraphVisualizer.jsx`

```jsx
import { useMemo } from "react";
import ReactFlow, { Background, Controls, MiniMap } from "reactflow";
import "reactflow/dist/style.css";
import { motion } from "framer-motion";

const nodeTypes = {
  custom: ({ data }) => (
    <motion.div
      initial={{ scale: 0 }}
      animate={{ scale: 1 }}
      whileHover={{ scale: 1.1 }}
      transition={{ type: "spring", stiffness: 400, damping: 10 }}
      style={{
        background: data.color,
        color: "#ffffff",
        borderRadius: "50%",
        width: "40px",
        height: "40px",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        fontWeight: "bold",
        boxShadow: "0 4px 10px rgba(0, 0, 0, 0.2)",
        cursor: "grab",
      }}
    >
      {data.label}
    </motion.div>
  ),
};

function GraphVisualizer({ nodes, edges, theme, nodeNames, initialMatrix }) {
  const themeStyles = {
    light: {
      background: "#ffffff",
      nodeInitial: "linear-gradient(135deg, #10b981, #059669)",
      nodeFinal: "linear-gradient(135deg, #ef4444, #dc2626)",
      nodeNormal: "linear-gradient(135deg, #3b82f6, #2563eb)",
      edgeColor: "#3a7bd5",
      fontColor: "#1e293b",
      matrixBg: "bg-white",
      matrixHeader: "bg-gradient-to-r from-blue-500 to-cyan-500",
      matrixText: "text-white",
      matrixCell: "bg-gray-50",
    },
    dark: {
      background: "#0f172a",
      nodeInitial: "linear-gradient(135deg, #10b981, #059669)",
      nodeFinal: "linear-gradient(135deg, #ef4444, #dc2626)",
      nodeNormal: "linear-gradient(135deg, #3b82f6, #2563eb)",
      edgeColor: "#94a3b8",
      fontColor: "#f1f5f9",
      matrixBg: "bg-gray-800",
      matrixHeader: "bg-gradient-to-r from-blue-600 to-cyan-600",
      matrixCell: "bg-gray-700",
    },
  };

  const currentTheme = themeStyles[theme] || themeStyles.light;

  const normalizedNodes = useMemo(() => {
    if (!nodes || nodes.length === 0) return [];
    return nodes.map((n, index) => ({
      id: `${n.id || index}`,
      type: "custom",
      data: {
        label: n.name,
        color: n.type === "initial" ? currentTheme.nodeInitial : n.type === "final" ? currentTheme.nodeFinal : currentTheme.nodeNormal,
      },
      position: { x: 100 + (index % 4) * 150, y: 100 + Math.floor(index / 4) * 120 },
      draggable: true,
    }));
  }, [nodes, currentTheme]);

  const reactFlowEdges = useMemo(() => {
    if (!edges || !nodes || edges.length === 0) return [];
    const validEdges = edges
      .map((e, index) => {
        const sourceNode = nodes.find((n) => n.name.toLowerCase() === e.source.toLowerCase());
        const targetNode = nodes.find((n) => n.name.toLowerCase() === e.target.toLowerCase());
        if (!sourceNode || !targetNode) return null;
        if (!e.weight || isNaN(Number(e.weight))) return null;
        return {
          id: `e${index}`,
          source: `${sourceNode.id || nodes.indexOf(sourceNode)}`,
          target: `${targetNode.id || nodes.indexOf(targetNode)}`,
          label: String(e.weight),
          style: { stroke: currentTheme.edgeColor, strokeWidth: 2 },
          labelStyle: { fill: currentTheme.edgeColor, fontWeight: "bold", fontSize: "12px" },
          labelBgStyle: { fill: theme === "light" ? "#ffffff" : "#1e293b", fillOpacity: 0.8, stroke: currentTheme.edgeColor, strokeWidth: 1, padding: "2px 5px", borderRadius: 4 },
          type: "smoothstep",
          markerEnd: { type: "arrowclosed", color: currentTheme.edgeColor },
        };
      })
      .filter((edge) => edge !== null);
    return validEdges;
  }, [edges, nodes, currentTheme, theme]);

  const renderInitialMatrix = () => {
    if (!initialMatrix || initialMatrix.length === 0 || !nodeNames || nodeNames.length === 0) return null;
    return (
      <div className={`mt-6 p-6 rounded-xl shadow-lg ${currentTheme.matrixBg}`}>
        <h3 className="text-xl font-semibold mb-4 text-gray-800 dark:text-gray-200">Matrice Initiale (D1)</h3>
        <div className="overflow-x-auto">
          <table className="border-collapse rounded-lg overflow-hidden shadow-md">
            <thead>
              <tr className={currentTheme.matrixHeader}>
                <th className={`p-3 ${currentTheme.matrixText}`}></th>
                {nodeNames.map((name, index) => (
                  <th key={index} className={`p-3 ${currentTheme.matrixText}`}>{name}</th>
                ))}
              </tr>
            </thead>
            <tbody>
              {initialMatrix.map((row, i) => (
                <tr key={i} className={i % 2 === 0 ? currentTheme.matrixCell : "bg-white dark:bg-gray-800"}>
                  <td className={`p-3 font-medium ${currentTheme.matrixHeader} ${currentTheme.matrixText}`}>{nodeNames[i]}</td>
                  {row.map((value, j) => (
                    <td key={j} className="p-3 text-center">
                      {value === null ? <span className="text-red-600">+∞</span> : value}
                    </td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    );
  };

  return (
    <div className="p-6 max-w-7xl mx-auto">
      <motion.div
        initial={{ opacity: 0, y: -20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="bg-gradient-to-r from-blue-600 to-cyan-500 rounded-xl shadow-xl p-6 mb-6"
      >
        <div className="flex items-center gap-3">
          <div className="w-8 h-8 rounded-full flex items-center justify-center bg-white/20">
            <svg className="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
            </svg>
          </div>
          <div>
            <h2 className="text-2xl font-bold text-white">Visualisation du Graphe</h2>
            <p className="text-sm text-white/80">Représentation interactive de votre graphe</p>
          </div>
        </div>
      </motion.div>

      {normalizedNodes.length === 0 && reactFlowEdges.length === 0 ? (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          className="flex flex-col items-center justify-center h-[500px] bg-white dark:bg-gray-800 rounded-xl shadow-lg"
        >
          <svg className="w-12 h-12 text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
          </svg>
          <h3 className="text-lg font-semibold text-gray-600 dark:text-gray-300">Aucun graphe à afficher</h3>
          <p className="text-sm text-gray-500 dark:text-gray-400">Créez ou sélectionnez un graphe pour commencer</p>
        </motion.div>
      ) : (
        <motion.div initial={{ opacity: 0, scale: 0.95 }} animate={{ opacity: 1, scale: 1 }} transition={{ duration: 0.3 }}>
          <div className="h-[500px] w-full rounded-xl overflow-hidden border border-gray-200 shadow-lg" style={{ background: currentTheme.background }}>
            <ReactFlow nodes={normalizedNodes} edges={reactFlowEdges} nodeTypes={nodeTypes} fitView fitViewOptions={{ padding: 0.2 }} nodesDraggable={true}>
              <Background color={theme === "light" ? "#e2e8f0" : "#334155"} gap={16} size={1} />
              <Controls />
              <MiniMap nodeColor={currentTheme.nodeNormal} />
            </ReactFlow>
          </div>
          <div className="flex gap-4 mt-4">
            <div className="flex items-center gap-2">
              <div className="w-3 h-3 rounded-full bg-green-500"></div>
              <span className="text-xs font-medium">Initial</span>
            </div>
            <div className="flex items-center gap-2">
              <div className="w-3 h-3 rounded-full bg-blue-500"></div>
              <span className="text-xs font-medium">Normal</span>
            </div>
            <div className="flex items-center gap-2">
              <div className="w-3 h-3 rounded-full bg-red-500"></div>
              <span className="text-xs font-medium">Final</span>
            </div>
          </div>
          {renderInitialMatrix()}
        </motion.div>
      )}
    </div>
  );
}

export default GraphVisualizer;
```

#### `src/components/Header.jsx`

```jsx
"use client";

import { motion } from "framer-motion";

function Header({ theme, toggleTheme }) {
  return (
    <motion.header
      initial={{ opacity: 0, y: -20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
      className="header"
    >
      <div className="header-content">
        <motion.div
          className="logo-container"
          whileHover={{ scale: 1.02 }}
          transition={{ type: "spring", stiffness: 400, damping: 10 }}
        >
          <div className="logo-icon">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
            <motion.div
              className="absolute inset-0 bg-blue-500 opacity-20 rounded-xl"
              animate={{ scale: [1, 1.2, 1] }}
              transition={{ duration: 2, repeat: Infinity }}
            />
          </div>
          <div className="logo-text">
            <h1>Algorithme de Demoucron</h1>
            <p>Recherche Opérationnelle</p>
          </div>
        </motion.div>

        <motion.button
          onClick={toggleTheme}
          whileHover={{ scale: 1.05 }}
          whileTap={{ scale: 0.95 }}
          className="theme-toggle"
        >
          {theme === "light" ? (
            <>
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
              </svg>
              Mode sombre
            </>
          ) : (
            <>
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
              </svg>
              Mode clair
            </>
          )}
        </motion.button>
      </div>
    </motion.header>
  );
}

export default Header;
```

#### `src/components/ResultsDisplay.jsx`

```jsx
import React, { useState } from "react";
import { motion } from "framer-motion";
import WijGraph from "./WijGraph";

function MatrixDisplay({ matrix, nodeNames }) {
  if (!matrix || !nodeNames) {
    return <p className="text-gray-500 dark:text-gray-400">Matrice non disponible</p>;
  }
  return (
    <div className="overflow-x-auto">
      <table className="border-collapse rounded-lg overflow-hidden shadow-md">
        <thead>
          <tr className="bg-gradient-to-r from-blue-500 to-cyan-500">
            <th className="p-3 text-white"></th>
            {nodeNames.map((name, index) => (
              <th key={index} className="p-3 text-white">{name}</th>
            ))}
          </tr>
        </thead>
        <tbody>
          {matrix.map((row, i) => (
            <tr key={i} className={i % 2 === 0 ? "bg-gray-50" : "bg-white dark:bg-gray-800"}>
              <td className="p-3 font-medium text-white bg-gradient-to-r from-blue-500 to-cyan-500">{nodeNames[i]}</td>
              {row.map((value, j) => (
                <td key={j} className="p-3 text-center">
                  {value === null ? <span className="text-red-600">+∞</span> : value}
                </td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

function CalculationsDisplay({ calculations, methode }) {
  if (!calculations) {
    return <p className="text-gray-500 dark:text-gray-400">Calculs non disponibles</p>;
  }
  return (
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
      <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
        <h4 className="text-lg font-semibold mb-3">Calculs W</h4>
        {calculations.map((calc, index) => (
          <div key={index} className="mb-2">
            <span className="font-medium">
              W_{calc.i}{calc.j}^{calc.k - 1} = V_{calc.i}{calc.k} + V_{calc.k}{calc.j} ={" "}
              {calc.V_ik ?? "∞"} + {calc.V_kj ?? "∞"} = {calc.W_ij ?? "∞"}
            </span>
          </div>
        ))}
      </div>
      <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
        <h4 className="text-lg font-semibold mb-3">Calculs V</h4>
        {calculations.map((calc, index) => (
          <div key={index} className="mb-2">
            <span className="font-medium">
              V_{calc.i}{calc.j}^{calc.k} = {methode === "min" ? "min" : "max"}(
              W_{calc.i}{calc.j}^{calc.k - 1}, V_{calc.i}{calc.j}^{calc.k - 1}) ={" "}
              {methode === "min" ? "min" : "max"}({calc.W_ij ?? "∞"}, {calc.V_ij_prev ?? "∞"}) ={" "}
              {calc.new_V_ij ?? "∞"}
            </span>
          </div>
        ))}
      </div>
    </div>
  );
}

function ResultsDisplay({ results, theme, nodes, nodeNames }) {
  const [expandedSteps, setExpandedSteps] = useState({});

  if (!results || results.error || !results.steps) {
    const error = results?.error || "Aucun résultat disponible";
    return <div className="p-6 text-center text-gray-500 dark:text-gray-400">{error}</div>;
  }

  const { steps, paths, methode } = results;
  const initialNode = nodes.find((n) => n.type === "initial");
  const finalNode = nodes.find((n) => n.type === "final");
  const optimalPathKey = initialNode && finalNode ? `${initialNode.name}-${finalNode.name}` : null;
  const optimalPath = optimalPathKey ? paths[optimalPathKey] : null;

  const toggleStep = (index) => {
    setExpandedSteps((prev) => ({ ...prev, [index]: !prev[index] }));
  };

  return (
    <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }} className="p-6">
      <h2 className="text-3xl font-bold mb-6">Résultats du Calcul</h2>

      <div className="mb-8">
        <h3 className="text-2xl font-semibold mb-4">Étapes de Calcul</h3>
        {steps.map((step, index) => (
          <div key={index} className="mb-4">
            <button onClick={() => toggleStep(index)} className="w-full text-left p-4 bg-gray-100 dark:bg-gray-700 rounded-t-lg">
              <h4 className="text-xl font-medium">
                Étape {step.step}: {step.intermediate_node ? `k = ${step.intermediate_node}` : "Initial"}
              </h4>
            </button>
            {expandedSteps[index] && (
              <motion.div initial={{ height: 0, opacity: 0 }} animate={{ height: "auto", opacity: 1 }} exit={{ height: 0, opacity: 0 }} className="p-4 bg-white dark:bg-gray-800 rounded-b-lg">
                <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                  <div>
                    <h5 className="text-lg font-semibold mb-2">Matrice D_{step.step}</h5>
                    <MatrixDisplay matrix={step.matrix} nodeNames={nodeNames} />
                  </div>
                  <div>
                    <h5 className="text-lg font-semibold mb-2">Graphe W_{step.intermediate_node}</h5>
                    <WijGraph
                      W={step.calculations || []}
                      k={step.intermediate_node}
                      currentMatrix={step.matrix}
                      stepIndex={index}
                      nodes={nodes}
                      nodeNames={nodeNames}
                    />
                  </div>
                </div>
                <CalculationsDisplay calculations={step.calculations} methode={methode} />
              </motion.div>
            )}
          </div>
        ))}
      </div>

      <div className="mb-8">
        <h3 className="text-2xl font-semibold mb-4">Matrice Finale</h3>
        <MatrixDisplay matrix={steps[steps.length - 1]?.matrix} nodeNames={nodeNames} />
      </div>

      <div>
        <h3 className="text-2xl font-semibold mb-4">Chemins Optimaux</h3>
        {optimalPath ? (
          <div className="p-4 bg-green-50 dark:bg-green-900 rounded-lg">
            <p className="font-medium">Chemin de {initialNode.name} à {finalNode.name}: {optimalPath.join(" → ")}</p>
          </div>
        ) : (
          <p className="text-gray-500 dark:text-gray-400">Aucun chemin optimal trouvé ou types de nœuds non définis</p>
        )}
      </div>
    </motion.div>
  );
}

export default ResultsDisplay;
```

#### `src/components/WijGraph.jsx`

```jsx
import { useEffect, useState } from "react";
import ReactFlow, { Controls, Background } from "reactflow";
import "reactflow/dist/style.css";

function WijGraph({ W, k, currentMatrix, stepIndex, nodes, nodeNames }) {
  const [isAnimating, setIsAnimating] = useState(false);

  const generateWijGraph = (W, k, currentMatrix, nodes, nodeNames) => {
    const rfNodes = [];
    const rfEdges = [];
    const uniqueNodes = new Set();
    const uniqueEdges = new Set();

    const kNodeId = `node-${k - 1}`;
    uniqueNodes.add(kNodeId);

    W.forEach(({ i, j }) => {
      uniqueNodes.add(`node-${i - 1}`);
      uniqueNodes.add(`node-${j - 1}`);

      const iIdx = i - 1;
      const jIdx = j - 1;
      const kIdx = k - 1;

      const edgeIkId = `edge-${iIdx}-${kIdx}-${stepIndex}`;
      if (!uniqueEdges.has(edgeIkId)) {
        uniqueEdges.add(edgeIkId);
        const weightIk = currentMatrix[iIdx][kIdx];
        if (weightIk !== null) {
          rfEdges.push({
            id: edgeIkId,
            source: `node-${iIdx}`,
            target: `node-${kIdx}`,
            label: `${weightIk}`,
            animated: isAnimating,
            style: { stroke: "#3b82f6", strokeWidth: 2 },
            labelStyle: { fill: "#3b82f6", fontWeight: "bold", fontSize: "12px", background: "white", padding: "2px 5px", borderRadius: "4px", border: "1px solid #3b82f6" },
          });
        }
      }

      const edgeKjId = `edge-${kIdx}-${jIdx}-${stepIndex}`;
      if (!uniqueEdges.has(edgeKjId)) {
        uniqueEdges.add(edgeKjId);
        const weightKj = currentMatrix[kIdx][jIdx];
        if (weightKj !== null) {
          rfEdges.push({
            id: edgeKjId,
            source: `node-${kIdx}`,
            target: `node-${jIdx}`,
            label: `${weightKj}`,
            animated: isAnimating,
            style: { stroke: "#06b6d4", strokeWidth: 2 },
            labelStyle: { fill: "#06b6d4", fontWeight: "bold", fontSize: "12px", background: "white", padding: "2px 5px", borderRadius: "4px", border: "1px solid #06b6d4" },
          });
        }
      }
    });

    uniqueNodes.forEach((nodeId) => {
      const nodeIndex = Number.parseInt(nodeId.split("-")[1]);
      const node = nodes.find((n) => n.name === nodeNames[nodeIndex]);
      const isKNode = nodeId === kNodeId;
      rfNodes.push({
        id: nodeId,
        data: { label: node?.name || nodeNames[nodeIndex] },
        position: { x: nodeIndex * 100, y: isKNode ? 0 : 100 },
        style: isKNode
          ? { background: "linear-gradient(135deg, #f59e0b, #f97316)", color: "white", borderRadius: "50%", width: "40px", height: "40px", display: "flex", alignItems: "center", justifyContent: "center", fontWeight: "bold", boxShadow: "0 4px 15px rgba(245, 158, 11, 0.5)" }
          : { background: "linear-gradient(135deg, #3b82f6, #06b6d4)", color: "white", borderRadius: "50%", width: "40px", height: "40px", display: "flex", alignItems: "center", justifyContent: "center", fontWeight: "bold", boxShadow: "0 4px 10px rgba(0, 0, 0, 0.2)" },
      });
    });

    return { nodes: rfNodes, edges: rfEdges };
  };

  const { nodes: initialNodes, edges: initialEdges } = generateWijGraph(W, k, currentMatrix, nodes, nodeNames);
  const [rfNodes, setNodes] = useState(initialNodes);
  const [rfEdges, setEdges] = useState(initialEdges);

  useEffect(() => {
    const { nodes: newNodes, edges: newEdges } = generateWijGraph(W, k, currentMatrix, nodes, nodeNames);
    setNodes(newNodes);
    setEdges(newEdges);
  }, [W, k, currentMatrix, nodes, nodeNames, isAnimating]);

  return (
    <div className="relative w-full h-64 rounded-lg overflow-hidden border-2 border-gray-200 dark:border-gray-700">
      {rfNodes.length > 0 ? (
        <ReactFlow nodes={rfNodes} edges={rfEdges} fitView>
          <Background color="#f0f0f0" gap={12} />
          <Controls />
          <div className="absolute top-2 right-2">
            <button onClick={() => setIsAnimating(!isAnimating)} className="bg-white dark:bg-gray-800 px-3 py-1 rounded-md text-xs font-medium shadow-sm border border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors">
              {isAnimating ? "Arrêter l'animation" : "Animer les arêtes"}
            </button>
          </div>
        </ReactFlow>
      ) : (
        <div className="flex items-center justify-center h-full">
          <p className="text-gray-500 dark:text-gray-400">Aucun chemin trouvé pour cette étape.</p>
        </div>
      )}
    </div>
  );
}

export default WijGraph;
```

#### `src/styles.css`

```css
@import url("https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap");

:root {
  --color-white: #ffffff;
  --color-black: #000000;
  --color-gray-50: #f8fafc;
  --color-gray-100: #f1f5f9;
  --color-gray-200: #e2e8f0;
  --color-gray-300: #cbd5e1;
  --color-gray-400: #94a3b8;
  --color-gray-500: #64748b;
  --color-gray-600: #475569;
  --color-gray-700: #334155;
  --color-gray-800: #1e293b;
  --color-gray-900: #0f172a;
  --color-blue-50: #eff6ff;
  --color-blue-100: #dbeafe;
  --color-blue-200: #bfdbfe;
  --color-blue-300: #93c5fd;
  --color-blue-400: #60a5fa;
  --color-blue-500: #3b82f6;
  --color-blue-600: #2563eb;
  --color-blue-700: #1d4ed8;
  --color-blue-800: #1e40af;
  --color-blue-900: #1e3a8a;
  --color-purple-500: #8b5cf6;
  --color-purple-600: #7c3aed;
  --color-purple-700: #6d28d9;
  --color-green-100: #dcfce7;
  --color-green-200: #bbf7d0;
  --color-green-300: #86efac;
  --color-green-500: #22c55e;
  --color-green-600: #16a34a;
  --color-green-700: #15803d;
  --color-green-800: #166534;
  --color-red-100: #fee2e2;
  --color-red-200: #fecaca;
  --color-red-300: #fca5a5;
  --color-red-500: #ef4444;
  --color-red-600: #dc2626;
  --color-red-700: #b91c1c;
  --color-red-800: #991b1b;
  --color-orange-500: #f97316;
  --color-pink-500: #ec4899;
  --color-pink-600: #db2777;
  --color-emerald-500: #10b981;
  --color-emerald-600: #059669;
  --color-indigo-50: #eef2ff;
  --color-indigo-950: #1e1b4b;
  --color-slate-50: #f8fafc;
  --color-slate-900: #0f172a;
  --color-cyan-500: #06b6d4;

  --spacing-1: 0.25rem;
  --spacing-2: 0.5rem;
  --spacing-3: 0.75rem;
  --spacing-4: 1rem;
  --spacing-5: 1.25rem;
  --spacing-6: 1.5rem;
  --spacing-8: 2rem;
  --spacing-12: 3rem;
  --spacing-16: 4rem;

  --radius-sm: 0.125rem;
  --radius-md: 0.375rem;
  --radius-lg: 0.5rem;
  --radius-xl: 0.75rem;
  --radius-2xl: 1rem;
  --radius-full: 9999px;

  --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);

  --bg-primary: var(--color-white);
  --bg-secondary: var(--color-gray-50);
  --text-primary: var(--color-gray-900);
  --text-secondary: var(--color-gray-600);
  --text-muted: var(--color-gray-500);
  --border-color: var(--color-gray-200);
  --card-bg: var(--color-white);
}

.dark {
  --bg-primary: var(--color-gray-900);
  --bg-secondary: var(--color-gray-800);
  --text-primary: var(--color-white);
  --text-secondary: var(--color-gray-300);
  --text-muted: var(--color-gray-400);
  --border-color: var(--color-gray-700);
  --card-bg: var(--color-gray-800);
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  line-height: 1.6;
  color: var(--text-primary);
  background-color: var(--bg-primary);
  transition: all 0.3s ease;
}

.container {
  max-width: 80rem;
  margin: 0 auto;
  padding: 0 var(--spacing-4);
}

.flex {
  display: flex;
}

.flex-col {
  flex-direction: column;
}

.items-center {
  align-items: center;
}

.justify-center {
  justify-content: center;
}

.justify-between {
  justify-content: space-between;
}

.gap-2 {
  gap: var(--spacing-2);
}

.gap-3 {
  gap: var(--spacing-3);
}

.gap-4 {
  gap: var(--spacing-4);
}

.gap-6 {
  gap: var(--spacing-6);
}

.gap-8 {
  gap: var(--spacing-8);
}

.grid {
  display: grid;
}

.grid-cols-1 {
  grid-template-columns: repeat(1, minmax(0, 1fr));
}

.grid-cols-2 {
  grid-template-columns: repeat(2, minmax(0, 1fr));
}

@media (min-width: 1280px) {
  .xl:grid-cols-2 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
}

.p-3 {
  padding: var(--spacing-3);
}

.p-4 {
  padding: var(--spacing-4);
}

.p-6 {
  padding: var(--spacing-6);
}

.px-2 {
  padding-left: var(--spacing-2);
  padding-right: var(--spacing-2);
}

.px-3 {
  padding-left: var(--spacing-3);
  padding-right: var(--spacing-3);
}

.py-1 {
  padding-top: var(--spacing-1);
  padding-bottom: var(--spacing-1);
}

.py-2 {
  padding-top: var(--spacing-2);
  padding-bottom: var(--spacing-2);
}

.mb-2 {
  margin-bottom: var(--spacing-2);
}

.mb-4 {
  margin-bottom: var(--spacing-4);
}

.mb-6 {
  margin-bottom: var(--spacing-6);
}

.mb-8 {
  margin-bottom: var(--spacing-8);
}

.mt-4 {
  margin-top: var(--spacing-4);
}

.mt-6 {
  margin-top: var(--spacing-6);
}

.w-full {
  width: 100%;
}

.w-20 {
  width: 5rem;
}

.w-32 {
  width: 8rem;
}

.h-64 {
  height: 16rem;
}

.text-xs {
  font-size: 0.75rem;
  line-height: 1rem;
}

.text-sm {
  font-size: 0.875rem;
  line-height: 1.25rem;
}

.text-lg {
  font-size: 1.125rem;
  line-height: 1.75rem;
}

.text-xl {
  font-size: 1.25rem;
  line-height: 1.75rem;
}

.text-2xl {
  font-size: 1.5rem;
  line-height: 2rem;
}

.text-3xl {
  font-size: 1.875rem;
  line-height: 2.25rem;
}

.font-medium {
  font-weight: 500;
}

.font-semibold {
  font-weight: 600;
}

.font-bold {
  font-weight: 700;
}

.text-center {
  text-align: center;
}

.text-white {
  color: var(--color-white);
}

.text-primary {
  color: var(--text-primary);
}

.text-secondary {
  color: var(--text-secondary);
}

.text-muted {
  color: var(--text-muted);
}

.bg-white {
  background-color: var(--color-white);
}

.bg-card {
  background-color: var(--card-bg);
}

.bg-gray-50 {
  background-color: var(--color-gray-50);
}

.bg-gray-100 {
  background-color: var(--color-gray-100);
}

.bg-gray-800 {
  background-color: var(--color-gray-800);
}

.border {
  border: 1px solid var(--border-color);
}

.rounded-lg {
  border-radius: var(--radius-lg);
}

.rounded-xl {
  border-radius: var(--radius-xl);
}

.rounded-2xl {
  border-radius: var(--radius-2xl);
}

.rounded-full {
  border-radius: var(--radius-full);
}

.shadow-sm {
  box-shadow: var(--shadow-sm);
}

.shadow-md {
  box-shadow: var(--shadow-md);
}

.shadow-lg {
  box-shadow: var(--shadow-lg);
}

.shadow-xl {
  box-shadow: var(--shadow-xl);
}

.overflow-hidden {
  overflow: hidden;
}

.overflow-x-auto {
  overflow-x: auto;
}

.transition-all {
  transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
}

.app-container {
  min-height: 100vh;
  background: linear-gradient(135deg, var(--color-slate-50), var(--color-blue-50), var(--color-indigo-50));
  transition: all 0.5s ease;
}

.dark .app-container {
  background: linear-gradient(135deg, var(--color-gray-900), var(--color-slate-900), var(--color-indigo-950));
}

.header {
  position: sticky;
  top: 0;
  z-index: 50;
  width: 100%;
  background: rgba(255, 255, 255, 0.8);
  backdrop-filter: blur(12px);
  border-bottom: 1px solid var(--border-color);
}

.dark .header {
  background: rgba(17, 24, 39, 0.8);
}

.header-content {
  max-width: 80rem;
  margin: 0 auto;
  padding: var(--spacing-4);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.logo-container {
  display: flex;
  align-items: center;
  gap: var(--spacing-4);
  cursor: pointer;
}

.logo-icon {
  position: relative;
  width: 3rem;
  height: 3rem;
  background: linear-gradient(135deg, var(--color-blue-500), var(--color-purple-600));
  border-radius: var(--radius-xl);
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: var(--shadow-lg);
}

.logo-icon svg {
  width: 1.75rem;
  height: 1.75rem;
  color: white;
}

.logo-text h1 {
  font-size: 1.5rem;
  font-weight: 700;
  background: linear-gradient(to right, var(--color-blue-600), var(--color-purple-600));
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  margin: 0;
}

.logo-text p {
  font-size: 0.875rem;
  color: var(--text-muted);
  margin: 0;
}

.theme-toggle {
  display: flex;
  align-items: center;
  gap: var(--spacing-2);
  padding: var(--spacing-2) var(--spacing-4);
  background: var(--color-gray-100);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-lg);
  cursor: pointer;
  transition: all 0.2s;
  font-size: 0.875rem;
}

.dark .theme-toggle {
  background: var(--color-gray-700);
}

.theme-toggle:hover {
  background: var(--color-gray-200);
}

.dark .theme-toggle:hover {
  background: var(--color-gray-600);
}

.main-content {
  max-width: 80rem;
  margin: 0 auto;
  padding: 0 var(--spacing-4);
  padding-top: var(--spacing-8);
  padding-bottom: var(--spacing-8);
}

.hero-section {
  text-align: center;
  margin-bottom: var(--spacing-12);
}

.hero-title {
  font-size: 2.25rem;
  font-weight: 700;
  background: linear-gradient(to right, var(--color-blue-600), var(--color-purple-600));
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  margin-bottom: var(--spacing-4);
}

.hero-description {
  font-size: 1.125rem;
  color: var(--text-secondary);
  max-width: 48rem;
  margin: 0 auto;
  line-height: 1.625;
}

.card {
  background: var(--card-bg);
  border-radius: var(--radius-2xl);
  box-shadow: var(--shadow-xl);
  border: 1px solid var(--border-color);
  overflow: hidden;
  transition: box-shadow 0.3s;
}

.card:hover {
  box-shadow: var(--shadow-xl);
}

.card-header {
  display: flex;
  align-items: center;
  gap: var(--spacing-3);
  margin-bottom: var(--spacing-6);
}

.card-icon {
  width: 2rem;
  height: 2rem;
  background: linear-gradient(135deg, var(--color-blue-500), var(--color-purple-600));
  border-radius: var(--radius-lg);
  display: flex;
  align-items: center;
  justify-content: center;
}

.card-icon svg {
  width: 1.25rem;
  height: 1.25rem;
  color: white;
}

.card-title {
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--text-primary);
  margin: 0;
}

.card-subtitle {
  font-size: 0.875rem;
  color: var(--text-muted);
  margin: 0;
}

.section-title {
  font-size: 1.125rem;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: var(--spacing-4);
}

.form-group {
  margin-bottom: var(--spacing-4);
}

.form-label {
  display: block;
  font-size: 0.875rem;
  font-weight: 500;
  color: var(--text-secondary);
  margin-bottom: var(--spacing-2);
}

.form-input,
.form-select {
  width: 100%;
  padding: var(--spacing-2) var(--spacing-3);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-lg);
  background: var(--card-bg);
  color: var(--text-primary);
  font-size: 0.875rem;
  transition: all 0.2s;
}

.form-input:focus,
.form-select:focus {
  outline: 2px solid var(--color-blue-500);
  outline-offset: 2px;
  border-color: transparent;
}

.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: var(--spacing-2);
  padding: var(--spacing-2) var(--spacing-4);
  border: none;
  border-radius: var(--radius-lg);
  font-size: 0.875rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  text-decoration: none;
}

.btn-primary {
  background: var(--color-blue-600);
  color: white;
}

.btn-primary:hover {
  background: var(--color-blue-700);
}

.btn-success {
  background: var(--color-green-600);
  color: white;
}

.btn-success:hover {
  background: var(--color-green-700);
}

.btn-purple {
  background: var(--color-purple-600);
  color: white;
}

.btn-purple:hover {
  background: var(--color-purple-700);
}

.btn-gradient {
  background: linear-gradient(to right, var(--color-blue-600), var(--color-purple-600));
  color: white;
  font-size: 1.125rem;
  font-weight: 600;
  height: 3.5rem;
  box-shadow: var(--shadow-lg);
}

.btn-gradient:hover {
  background: linear-gradient(to right, var(--color-blue-700), var(--color-purple-700));
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.mode-selector {
  display: flex;
  justify-content: center;
  gap: 1rem;
  margin-bottom: var(--spacing-8);
}

.mode-selector button {
  padding: 0.5rem 1rem;
  border: 1px solid var(--border-color);
  border-radius: var(--radius-lg);
  background: var(--card-bg);
  color: var(--text-primary);
  cursor: pointer;
  transition: all 0.2s;
}

.mode-selector button.active {
  background: var(--color-blue-500);
  color: white;
}

.method-selection {
  background: var(--card-bg);
  border-radius: var(--radius-xl);
  padding: var(--spacing-6);
}

.radio-group {
  display: flex;
  gap: var(--spacing-6);
}

.radio-item {
  display: flex;
  align-items: center;
  gap: var(--spacing-3);
  cursor: pointer;
}

.radio-input {
  width: 1rem;
  height: 1rem;
  accent-color: var(--color-blue-600);
}

.react-flow__node {
  font-family: inherit;
}

.react-flow__edge-text {
  font-family: inherit;
}

.react-flow__controls {
  background: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  box-shadow: var(--shadow-lg);
}

.react-flow__controls button {
  background: var(--card-bg);
  border-bottom: 1px solid var(--border-color);
  color: var(--text-primary);
}

.react-flow__controls button:hover {
  background: var(--color-gray-50);
}

.dark .react-flow__controls button:hover {
  background: var(--color-gray-700);
}

.react-flow__minimap {
  background: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  box-shadow: var(--shadow-lg);
}
```

---

### Installation and Running

1. **Backend Setup:**
   - Ensure Django and required packages (`djangorestframework`, `drf-yasg`, `numpy`) are installed.
   - Run migrations: `python manage.py makemigrations` and `python manage.py migrate`.
   - Start the server: `python manage.py runserver`.

2. **Frontend Setup:**
   - Install dependencies: `npm install` (ensure `axios`, `framer-motion`, `reactflow` are listed in `package.json`).
   - Start the development server: `npm run dev`.

3. **Usage:**
   - Access the app at `http://localhost:5173`.
   - Use the mode selector to switch between "Éditeur de Graphe" and "Entrée Matricielle".
   - Build a graph or input a matrix, select the method (min/max), and click "Calculer les Chemins Optimaux" to see results.

---